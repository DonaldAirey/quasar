//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MarkThree.Guardian.External
{
    using MarkThree.Guardian;
    using MarkThree.Guardian.Server;
    using MarkThree;
    using System;
    using System.Collections;
    using System.Data;
    using System.Data.SqlClient;
    
    
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Diagnostics.DebuggerStepThrough()]
    public class DestinationOrder
    {
        
        /// This value is used to map the object to a persistent storage device.  The parameters for the storage
        /// are found in the configuration file for this service.
        public static string PersistentStore = "Guardian";
        
        /// This member provides access to the in-memory database.
        private static ServerMarketData serverMarketData = new ServerMarketData();
        
        /// This is an array of indices used to find a record based on an external identifier.
        public static System.Data.DataView[] externalKeyArray;
        
        /// <summary>Initializes the static elements of an Object.</summary>
        static DestinationOrder()
        {
            // The table must be locked before the indices can be read into an accelerator array.
            ServerMarketData.DestinationOrderLock.AcquireReaderLock(System.Threading.Timeout.Infinite);
            // Accessor for the DestinationOrder Table.
            ServerMarketData.DestinationOrderDataTable destinationOrderTable = ServerMarketData.DestinationOrder;
            // This does an indirect lookup operation using the views created for the ExternalId columns.  Take the index of the user
            // identifier column calcualted above and use it to find a record containing the external identifier.
            DestinationOrder.externalKeyArray = new DataView[] {
                    destinationOrderTable.KeyDestinationOrderExternalId0};
            // The table must be released after the array is constructed.
            ServerMarketData.DestinationOrderLock.ReleaseReaderLock();
        }
        
        /// <summary>Calculates which index to uses when searching for external identifiers.</summary>
        /// <param name="configurationId">Specified which mappings (user id columns) to use when looking up external identifiers.</param>
        /// <param name="parameterId">The name of the parameter as specified in the configuration table.</param>
        /// <returns>An index into the array of keys to search for an external identifier.</returns>
        public static int GetExternalKeyIndex(object configurationId, string parameterId)
        {
            // Translate the configurationId and the predefined parameter name into an index into the array of user ids.  The index
            // is where we expect to find the identifier.  That is, an index of 1 will guide the lookup logic to use the external
            // identifiers found in the 'ExternalId1' column.
            int externalKeyIndex = 0;
            if ((configurationId != null))
            {
                // Attempt to find a external column specification for the given configuration and parameter.  This record tells us
                // which column to use in the array of external columns.
                ServerMarketData.ConfigurationRow configurationRow = ServerMarketData.Configuration.FindByConfigurationIdParameterId(((string)(configurationId)), parameterId);
                if ((configurationRow != null))
                {
                    externalKeyIndex = configurationRow.ColumnIndex;
                }
            }
            // This is the index into the array of keys to be used when searching for an external identifier.
            return externalKeyIndex;
        }
        
        /// <summary>Finds a a DestinationOrder record using a configuration and an external identifier.</summary>
        /// <param name="configurationId">Specified which mappings (user id columns) to use when looking up external identifiers.</param>
        /// <param name="parameterId">The name of the parameter as specified in the configuration table.</param>
        /// <param name="externalId">The external (user supplied) identifier for the record.</param>
        public static int FindKey(object configurationId, string parameterId, object externalId)
        {
            // A missing key will never match a column.
            if ((externalId == null))
            {
                return int.MinValue;
            }
            // Accessor for the DestinationOrder Table.
            ServerMarketData.DestinationOrderDataTable destinationOrderTable = ServerMarketData.DestinationOrder;
            // Look for the record using the external identifier.  The configuration selected the key to use, which effectively
            // selected the external id column to use for the search.  If a record is found in the view, a translation still needs
            // to be made back to the original table before an index to the record can be returned to the caller.
            int externalKeyIndex = DestinationOrder.GetExternalKeyIndex(configurationId, parameterId);
            System.Data.DataView externalKeyView = DestinationOrder.externalKeyArray[externalKeyIndex];
            int recordIndex = externalKeyView.Find(new object[] {
                        externalId});
            if ((recordIndex == -1))
            {
                return int.MinValue;
            }
            return ((int)(externalKeyView[recordIndex].Row[destinationOrderTable.DestinationOrderIdColumn]));
        }
        
        /// <summary>Finds a a DestinationOrder record using a configuration and an external identifier.</summary>
        /// <param name="configurationId">Specified which mappings (user id columns) to use when looking up external identifiers.</param>
        /// <param name="externalId">The external identifier for the record.</param>
        public static int FindRequiredKey(object configurationId, string parameterId, string externalId)
        {
            // Look up the internal identifier using the configuration to select the ExternalId column and the external identifier to identify the record
            int internalId = DestinationOrder.FindKey(configurationId, parameterId, externalId);
            if ((internalId == int.MinValue))
            {
                throw new Exception(string.Format("The DestinationOrder table does not have a record identified by \'{0}\'", externalId));
            }
            // Return the internal identifier.
            return internalId;
        }
        
        /// <summary>Finds a a DestinationOrder record using a configuration and an external identifier.</summary>
        /// <param name="configurationId">Specified which mappings (user id columns) to use when looking up external identifiers.</param>
        /// <param name="externalId">The external (user supplied) identifier for the record.</param>
        public static object FindOptionalKey(object configurationId, string parameterId, object externalId)
        {
            // Look up the internal identifier using the the configuration to specify which ExternalId column to use as an index.
            object internalId = null;
            if ((externalId != null))
            {
                internalId = DestinationOrder.FindKey(configurationId, parameterId, ((string)(externalId)));
                if ((((int)(internalId)) == int.MinValue))
                {
                    throw new Exception(string.Format("The DestinationOrder table does not have a record identified by \'{0}\'", externalId));
                }
            }
            // Return the internal identifier.
            return internalId;
        }
        
        /// <summary>Collects the table lock request(s) for an 'Load' operation</summary>
        /// <param name="adoTransaction">A collection of table locks required for this operation</param>
        public static void Load(AdoTransaction adoTransaction)
        {
            // Call the internal methods to lock the tables required for an insert or update operation.
            MarkThree.Guardian.Core.DestinationOrder.Insert(adoTransaction);
            MarkThree.Guardian.Core.DestinationOrder.Update(adoTransaction);
            // These table lock(s) are required for the 'Load' operation.
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.DestinationOrderLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.ConfigurationLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.DestinationLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.PriceTypeLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.StateLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.StatusLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.TimeInForceLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.ObjectLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.UserLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.TraderLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.WorkingOrderLock);
        }
        
        /// <summary>Loads a DestinationOrder record using Metadata Parameters.</summary>
        /// <param name="transaction">Contains the parameters and exceptions for this command.</param>
        public static void Load(ParameterList parameters)
        {
            // Accessor for the DestinationOrder Table.
            ServerMarketData.DestinationOrderDataTable destinationOrderTable = ServerMarketData.DestinationOrder;
            // Extract the parameters from the command batch.
            AdoTransaction adoTransaction = parameters["adoTransaction"];
            SqlTransaction sqlTransaction = parameters["sqlTransaction"];
            object configurationId = parameters["configurationId"].Value;
            object canceledQuantity = parameters["canceledQuantity"].Value;
            object canceledTime = parameters["canceledTime"].Value;
            System.DateTime createdTime = parameters["createdTime"];
            int createdUserId = parameters["createdUserId"];
            string externalDestinationId = parameters["destinationId"];
            object externalDestinationOrderId = parameters["destinationOrderId"].Value;
            object externalId0 = parameters["externalId0"].Value;
            object isCanceledByUser = parameters["isCanceledByUser"].Value;
            object isHidden = parameters["isHidden"].Value;
            object limitPrice = parameters["limitPrice"].Value;
            System.DateTime modifiedTime = parameters["modifiedTime"];
            int modifiedUserId = parameters["modifiedUserId"];
            int orderTypeCode = parameters["orderTypeCode"];
            decimal orderedQuantity = parameters["orderedQuantity"];
            string externalPriceTypeCode = parameters["priceTypeCode"];
            string externalStateCode = parameters["stateCode"];
            string externalStatusCode = parameters["statusCode"];
            object stopPrice = parameters["stopPrice"].Value;
            object externalTraderId = parameters["traderId"].Value;
            string externalTimeInForceCode = parameters["timeInForceCode"];
            string externalWorkingOrderId = parameters["workingOrderId"];
            // The row versioning is largely disabled for external operations.  The value is returned to the caller in the
            // event it's needed for operations within the batch.
            long rowVersion = long.MinValue;
            // Resolve External Identifiers
            int destinationId = Destination.FindRequiredKey(configurationId, "destinationId", externalDestinationId);
            int destinationOrderId = DestinationOrder.FindKey(configurationId, "destinationOrderId", externalDestinationOrderId);
            int priceTypeCode = PriceType.FindRequiredKey(configurationId, "priceTypeCode", externalPriceTypeCode);
            int stateCode = State.FindRequiredKey(configurationId, "stateCode", externalStateCode);
            int statusCode = Status.FindRequiredKey(configurationId, "statusCode", externalStatusCode);
            object traderId = Trader.FindOptionalKey(configurationId, "traderId", externalTraderId);
            int timeInForceCode = TimeInForce.FindRequiredKey(configurationId, "timeInForceCode", externalTimeInForceCode);
            int workingOrderId = WorkingOrder.FindRequiredKey(configurationId, "workingOrderId", externalWorkingOrderId);
            // The load operation will create a record if it doesn't exist, or update an existing record.  The external
            // identifier is used to determine if a record exists with the same key.
            if ((destinationOrderId == int.MinValue))
            {
                // Populate the 'externalId' varaibles so that the external identifier can be used to find the row when an
                // external method is called with the same 'configurationId' parameter.
                int externalKeyIndex = DestinationOrder.GetExternalKeyIndex(configurationId, "destinationOrderId");
                object[] externalIdArray = new object[1];
                externalIdArray[externalKeyIndex] = externalDestinationOrderId;
                externalId0 = externalIdArray[0];
                // Call the internal method to complete the operation.
                MarkThree.Guardian.Core.DestinationOrder.Insert(adoTransaction, sqlTransaction, ref rowVersion, canceledQuantity, canceledTime, createdTime, createdUserId, destinationId, externalId0, isCanceledByUser, isHidden, limitPrice, modifiedTime, modifiedUserId, orderTypeCode, orderedQuantity, priceTypeCode, stateCode, statusCode, stopPrice, traderId, timeInForceCode, workingOrderId);
            }
            else
            {
                // While the optimistic concurrency checking is disabled for the external methods, the internal methods
                // still need to perform the check.  This ncurrency checking logic by finding the current row version to be
                // will bypass the coused when the internal method is called.
                ServerMarketData.DestinationOrderRow destinationOrderRow = destinationOrderTable.FindByDestinationOrderId(destinationOrderId);
                rowVersion = ((long)(destinationOrderRow[destinationOrderTable.RowVersionColumn]));
                // Call the internal method to complete the operation.
                MarkThree.Guardian.Core.DestinationOrder.Update(adoTransaction, sqlTransaction, ref rowVersion, canceledQuantity, canceledTime, createdTime, createdUserId, destinationId, destinationOrderId, externalId0, isCanceledByUser, isHidden, limitPrice, modifiedTime, modifiedUserId, orderTypeCode, orderedQuantity, priceTypeCode, stateCode, statusCode, stopPrice, traderId, timeInForceCode, workingOrderId);
            }
            // Return values.
            parameters["rowVersion"] = rowVersion;
        }
        
        /// <summary>Collects the table lock request(s) for an 'Update' operation</summary>
        /// <param name="adoTransaction">A collection of table locks required for this operation</param>
        public static void Update(AdoTransaction adoTransaction)
        {
            // Call the internal methods to lock the tables required for an insert or update operation.
            MarkThree.Guardian.Core.DestinationOrder.Insert(adoTransaction);
            MarkThree.Guardian.Core.DestinationOrder.Update(adoTransaction);
            // These table lock(s) are required for the 'Update' operation.
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.DestinationOrderLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.ConfigurationLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.DestinationLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.PriceTypeLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.StateLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.StatusLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.TimeInForceLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.ObjectLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.UserLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.TraderLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.WorkingOrderLock);
        }
        
        /// <summary>Updates a DestinationOrder record using Metadata Parameters.</summary>
        /// <param name="transaction">Contains the parameters and exceptions for this command.</param>
        public static void Update(ParameterList parameters)
        {
            // Accessor for the DestinationOrder Table.
            ServerMarketData.DestinationOrderDataTable destinationOrderTable = ServerMarketData.DestinationOrder;
            // Extract the parameters from the command batch.
            AdoTransaction adoTransaction = parameters["adoTransaction"];
            SqlTransaction sqlTransaction = parameters["sqlTransaction"];
            object configurationId = parameters["configurationId"].Value;
            object canceledQuantity = parameters["canceledQuantity"].Value;
            object canceledTime = parameters["canceledTime"].Value;
            object createdTime = parameters["createdTime"].Value;
            object createdUserId = parameters["createdUserId"].Value;
            object externalDestinationId = parameters["destinationId"].Value;
            string externalDestinationOrderId = ((string)(parameters["destinationOrderId"]));
            object isCanceledByUser = parameters["isCanceledByUser"].Value;
            object isHidden = parameters["isHidden"].Value;
            object limitPrice = parameters["limitPrice"].Value;
            object modifiedTime = parameters["modifiedTime"].Value;
            object modifiedUserId = parameters["modifiedUserId"].Value;
            object orderTypeCode = parameters["orderTypeCode"].Value;
            object orderedQuantity = parameters["orderedQuantity"].Value;
            object externalPriceTypeCode = parameters["priceTypeCode"].Value;
            object externalStateCode = parameters["stateCode"].Value;
            object externalStatusCode = parameters["statusCode"].Value;
            object stopPrice = parameters["stopPrice"].Value;
            object externalTraderId = parameters["traderId"].Value;
            object externalTimeInForceCode = parameters["timeInForceCode"].Value;
            object externalWorkingOrderId = parameters["workingOrderId"].Value;
            // The row versioning is largely disabled for external operations.
            long rowVersion = long.MinValue;
            // Resolve External Identifiers
            object destinationId = Destination.FindOptionalKey(configurationId, "destinationId", externalDestinationId);
            int destinationOrderId = DestinationOrder.FindRequiredKey(configurationId, "destinationOrderId", externalDestinationOrderId);
            object priceTypeCode = PriceType.FindOptionalKey(configurationId, "priceTypeCode", externalPriceTypeCode);
            object stateCode = State.FindOptionalKey(configurationId, "stateCode", externalStateCode);
            object statusCode = Status.FindOptionalKey(configurationId, "statusCode", externalStatusCode);
            object traderId = Trader.FindOptionalKey(configurationId, "traderId", externalTraderId);
            object timeInForceCode = TimeInForce.FindOptionalKey(configurationId, "timeInForceCode", externalTimeInForceCode);
            object workingOrderId = WorkingOrder.FindOptionalKey(configurationId, "workingOrderId", externalWorkingOrderId);
            // While the optimistic concurrency checking is disabled for the external methods, the internal methods
            // still need to perform the check.  This ncurrency checking logic by finding the current row version to be
            // will bypass the coused when the internal method is called.
            ServerMarketData.DestinationOrderRow destinationOrderRow = destinationOrderTable.FindByDestinationOrderId(destinationOrderId);
            rowVersion = ((long)(destinationOrderRow[destinationOrderTable.RowVersionColumn]));
            // Call the internal method to complete the operation.
            MarkThree.Guardian.Core.DestinationOrder.Update(adoTransaction, sqlTransaction, ref rowVersion, canceledQuantity, canceledTime, createdTime, createdUserId, destinationId, destinationOrderId, null, isCanceledByUser, isHidden, limitPrice, modifiedTime, modifiedUserId, orderTypeCode, orderedQuantity, priceTypeCode, stateCode, statusCode, stopPrice, traderId, timeInForceCode, workingOrderId);
            // Return values.
            parameters["rowVersion"] = rowVersion;
        }
        
        /// <summary>Collects the table lock request(s) for an 'Delete' operation</summary>
        /// <param name="adoTransaction">A collection of table locks required for this operation</param>
        public static void Delete(AdoTransaction adoTransaction)
        {
            // Call the internal methods to lock the tables required for an insert or update operation.
            MarkThree.Guardian.Core.DestinationOrder.Delete(adoTransaction);
            // These table lock(s) are required for the 'Delete' operation.
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.DestinationOrderLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.ConfigurationLock);
        }
        
        /// <summary>Deletes a DestinationOrder record using Metadata Parameters.</summary>
        /// <param name="transaction">Contains the parameters and exceptions for this command.</param>
        public static void Delete(ParameterList parameters)
        {
            // Accessor for the DestinationOrder Table.
            ServerMarketData.DestinationOrderDataTable destinationOrderTable = ServerMarketData.DestinationOrder;
            // Extract the parameters from the command batch.
            AdoTransaction adoTransaction = parameters["adoTransaction"];
            SqlTransaction sqlTransaction = parameters["sqlTransaction"];
            object configurationId = parameters["configurationId"].Value;
            string externalDestinationOrderId = parameters["destinationOrderId"];
            // The row versioning is largely disabled for external operations.
            long rowVersion = long.MinValue;
            // Find the internal identifier using the primar key elements.
            // identifier is used to determine if a record exists with the same key.
            int destinationOrderId = DestinationOrder.FindRequiredKey(configurationId, "destinationOrderId", externalDestinationOrderId);
            // While the optimistic concurrency checking is disabled for the external methods, the internal methods
            // still need to perform the check.  This ncurrency checking logic by finding the current row version to be
            // will bypass the coused when the internal method is called.
            ServerMarketData.DestinationOrderRow destinationOrderRow = destinationOrderTable.FindByDestinationOrderId(destinationOrderId);
            rowVersion = ((long)(destinationOrderRow[destinationOrderTable.RowVersionColumn]));
            // Call the internal method to complete the operation.
            MarkThree.Guardian.Core.DestinationOrder.Delete(adoTransaction, sqlTransaction, rowVersion, destinationOrderId);
        }
        
        /// <summary>Collects the table lock request(s) for an 'Archive' operation</summary>
        /// <param name="adoTransaction">A collection of table locks required for this operation</param>
        public static void Archive(AdoTransaction adoTransaction)
        {
            // Call the internal methods to lock the tables required for an insert or update operation.
            MarkThree.Guardian.Core.DestinationOrder.Archive(adoTransaction);
            // These table lock(s) are required for the 'Archive' operation.
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.DestinationOrderLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.ConfigurationLock);
        }
        
        /// <summary>Archives a DestinationOrder record using Metadata Parameters.</summary>
        /// <param name="transaction">Contains the parameters and exceptions for this command.</param>
        public static void Archive(ParameterList parameters)
        {
            // Accessor for the DestinationOrder Table.
            ServerMarketData.DestinationOrderDataTable destinationOrderTable = ServerMarketData.DestinationOrder;
            // Extract the parameters from the command batch.
            AdoTransaction adoTransaction = parameters["adoTransaction"];
            SqlTransaction sqlTransaction = parameters["sqlTransaction"];
            object configurationId = parameters["configurationId"].Value;
            string externalDestinationOrderId = parameters["destinationOrderId"];
            // The row versioning is largely disabled for external operations.
            long rowVersion = long.MinValue;
            // Find the internal identifier using the primar key elements.
            // identifier is used to determine if a record exists with the same key.
            int destinationOrderId = DestinationOrder.FindRequiredKey(configurationId, "destinationOrderId", externalDestinationOrderId);
            // While the optimistic concurrency checking is disabled for the external methods, the internal methods
            // still need to perform the check.  This ncurrency checking logic by finding the current row version to be
            // will bypass the coused when the internal method is called.
            ServerMarketData.DestinationOrderRow destinationOrderRow = destinationOrderTable.FindByDestinationOrderId(destinationOrderId);
            rowVersion = ((long)(destinationOrderRow[destinationOrderTable.RowVersionColumn]));
            // Call the internal method to complete the operation.
            MarkThree.Guardian.Core.DestinationOrder.Archive(adoTransaction, sqlTransaction, rowVersion, destinationOrderId);
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
