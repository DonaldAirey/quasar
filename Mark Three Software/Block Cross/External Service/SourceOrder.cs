//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MarkThree.Guardian.External
{
    using MarkThree.Guardian;
    using MarkThree.Guardian.Server;
    using MarkThree;
    using System;
    using System.Collections;
    using System.Data;
    using System.Data.SqlClient;
    
    
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Diagnostics.DebuggerStepThrough()]
    public class SourceOrder
    {
        
        /// This value is used to map the object to a persistent storage device.  The parameters for the storage
        /// are found in the configuration file for this service.
        public static string PersistentStore = "Guardian";
        
        /// This member provides access to the in-memory database.
        private static ServerMarketData serverMarketData = new ServerMarketData();
        
        /// This is an array of indices used to find a record based on an external identifier.
        public static System.Data.DataView[] externalKeyArray;
        
        /// <summary>Initializes the static elements of an Object.</summary>
        static SourceOrder()
        {
            // The table must be locked before the indices can be read into an accelerator array.
            ServerMarketData.SourceOrderLock.AcquireReaderLock(System.Threading.Timeout.Infinite);
            // Accessor for the SourceOrder Table.
            ServerMarketData.SourceOrderDataTable sourceOrderTable = ServerMarketData.SourceOrder;
            // This does an indirect lookup operation using the views created for the ExternalId columns.  Take the index of the user
            // identifier column calcualted above and use it to find a record containing the external identifier.
            SourceOrder.externalKeyArray = new DataView[] {
                    sourceOrderTable.KeySourceOrderExternalId0};
            // The table must be released after the array is constructed.
            ServerMarketData.SourceOrderLock.ReleaseReaderLock();
        }
        
        /// <summary>Calculates which index to uses when searching for external identifiers.</summary>
        /// <param name="configurationId">Specified which mappings (user id columns) to use when looking up external identifiers.</param>
        /// <param name="parameterId">The name of the parameter as specified in the configuration table.</param>
        /// <returns>An index into the array of keys to search for an external identifier.</returns>
        public static int GetExternalKeyIndex(object configurationId, string parameterId)
        {
            // Translate the configurationId and the predefined parameter name into an index into the array of user ids.  The index
            // is where we expect to find the identifier.  That is, an index of 1 will guide the lookup logic to use the external
            // identifiers found in the 'ExternalId1' column.
            int externalKeyIndex = 0;
            if ((configurationId != null))
            {
                // Attempt to find a external column specification for the given configuration and parameter.  This record tells us
                // which column to use in the array of external columns.
                ServerMarketData.ConfigurationRow configurationRow = ServerMarketData.Configuration.FindByConfigurationIdParameterId(((string)(configurationId)), parameterId);
                if ((configurationRow != null))
                {
                    externalKeyIndex = configurationRow.ColumnIndex;
                }
            }
            // This is the index into the array of keys to be used when searching for an external identifier.
            return externalKeyIndex;
        }
        
        /// <summary>Finds a a SourceOrder record using a configuration and an external identifier.</summary>
        /// <param name="configurationId">Specified which mappings (user id columns) to use when looking up external identifiers.</param>
        /// <param name="parameterId">The name of the parameter as specified in the configuration table.</param>
        /// <param name="externalId">The external (user supplied) identifier for the record.</param>
        public static int FindKey(object configurationId, string parameterId, object externalId)
        {
            // A missing key will never match a column.
            if ((externalId == null))
            {
                return int.MinValue;
            }
            // Accessor for the SourceOrder Table.
            ServerMarketData.SourceOrderDataTable sourceOrderTable = ServerMarketData.SourceOrder;
            // Look for the record using the external identifier.  The configuration selected the key to use, which effectively
            // selected the external id column to use for the search.  If a record is found in the view, a translation still needs
            // to be made back to the original table before an index to the record can be returned to the caller.
            int externalKeyIndex = SourceOrder.GetExternalKeyIndex(configurationId, parameterId);
            System.Data.DataView externalKeyView = SourceOrder.externalKeyArray[externalKeyIndex];
            int recordIndex = externalKeyView.Find(new object[] {
                        externalId});
            if ((recordIndex == -1))
            {
                return int.MinValue;
            }
            return ((int)(externalKeyView[recordIndex].Row[sourceOrderTable.SourceOrderIdColumn]));
        }
        
        /// <summary>Finds a a SourceOrder record using a configuration and an external identifier.</summary>
        /// <param name="configurationId">Specified which mappings (user id columns) to use when looking up external identifiers.</param>
        /// <param name="externalId">The external identifier for the record.</param>
        public static int FindRequiredKey(object configurationId, string parameterId, string externalId)
        {
            // Look up the internal identifier using the configuration to select the ExternalId column and the external identifier to identify the record
            int internalId = SourceOrder.FindKey(configurationId, parameterId, externalId);
            if ((internalId == int.MinValue))
            {
                throw new Exception(string.Format("The SourceOrder table does not have a record identified by \'{0}\'", externalId));
            }
            // Return the internal identifier.
            return internalId;
        }
        
        /// <summary>Finds a a SourceOrder record using a configuration and an external identifier.</summary>
        /// <param name="configurationId">Specified which mappings (user id columns) to use when looking up external identifiers.</param>
        /// <param name="externalId">The external (user supplied) identifier for the record.</param>
        public static object FindOptionalKey(object configurationId, string parameterId, object externalId)
        {
            // Look up the internal identifier using the the configuration to specify which ExternalId column to use as an index.
            object internalId = null;
            if ((externalId != null))
            {
                internalId = SourceOrder.FindKey(configurationId, parameterId, ((string)(externalId)));
                if ((((int)(internalId)) == int.MinValue))
                {
                    throw new Exception(string.Format("The SourceOrder table does not have a record identified by \'{0}\'", externalId));
                }
            }
            // Return the internal identifier.
            return internalId;
        }
        
        /// <summary>Collects the table lock request(s) for an 'Load' operation</summary>
        /// <param name="adoTransaction">A collection of table locks required for this operation</param>
        public static void Load(AdoTransaction adoTransaction)
        {
            // Call the internal methods to lock the tables required for an insert or update operation.
            MarkThree.Guardian.Core.SourceOrder.Insert(adoTransaction);
            MarkThree.Guardian.Core.SourceOrder.Update(adoTransaction);
            // These table lock(s) are required for the 'Load' operation.
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.SourceOrderLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.ConfigurationLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.DestinationLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.OrderTypeLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.PriceTypeLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.ObjectLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.SecurityLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.StatusLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.TimeInForceLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.UserLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.WorkingOrderLock);
        }
        
        /// <summary>Loads a SourceOrder record using Metadata Parameters.</summary>
        /// <param name="transaction">Contains the parameters and exceptions for this command.</param>
        public static void Load(ParameterList parameters)
        {
            // Accessor for the SourceOrder Table.
            ServerMarketData.SourceOrderDataTable sourceOrderTable = ServerMarketData.SourceOrder;
            // Extract the parameters from the command batch.
            AdoTransaction adoTransaction = parameters["adoTransaction"];
            SqlTransaction sqlTransaction = parameters["sqlTransaction"];
            object configurationId = parameters["configurationId"].Value;
            System.DateTime createdTime = parameters["createdTime"];
            string externalCreatedUserId = parameters["createdUserId"];
            object externalDestinationId = parameters["destinationId"].Value;
            object externalId0 = parameters["externalId0"].Value;
            object isAdvertised = parameters["isAdvertised"].Value;
            object isAutoExecute = parameters["isAutoExecute"].Value;
            object isCanceled = parameters["isCanceled"].Value;
            object isHeld = parameters["isHeld"].Value;
            object isSteppedIn = parameters["isSteppedIn"].Value;
            object isSubmitted = parameters["isSubmitted"].Value;
            object limitPrice = parameters["limitPrice"].Value;
            object maximumVolatility = parameters["maximumVolatility"].Value;
            System.DateTime modifiedTime = parameters["modifiedTime"];
            string externalModifiedUserId = parameters["modifiedUserId"];
            object newsFreeTime = parameters["newsFreeTime"].Value;
            string externalOrderTypeCode = parameters["orderTypeCode"];
            decimal orderedQuantity = parameters["orderedQuantity"];
            string externalPriceTypeCode = parameters["priceTypeCode"];
            object receivedTime = parameters["receivedTime"].Value;
            string externalSecurityId = parameters["securityId"];
            object externalSettlementId = parameters["settlementId"].Value;
            object externalSourceOrderId = parameters["sourceOrderId"].Value;
            object startTime = parameters["startTime"].Value;
            string externalStatusCode = parameters["statusCode"];
            object stopPrice = parameters["stopPrice"].Value;
            object stopTime = parameters["stopTime"].Value;
            object submittedQuantity = parameters["submittedQuantity"].Value;
            object submittedTime = parameters["submittedTime"].Value;
            object targetPrice = parameters["targetPrice"].Value;
            string externalTimeInForceCode = parameters["timeInForceCode"];
            string externalWorkingOrderId = parameters["workingOrderId"];
            // The row versioning is largely disabled for external operations.  The value is returned to the caller in the
            // event it's needed for operations within the batch.
            long rowVersion = long.MinValue;
            // Resolve External Identifiers
            int createdUserId = User.FindRequiredKey(configurationId, "createdUserId", externalCreatedUserId);
            object destinationId = Destination.FindOptionalKey(configurationId, "destinationId", externalDestinationId);
            int modifiedUserId = User.FindRequiredKey(configurationId, "modifiedUserId", externalModifiedUserId);
            int orderTypeCode = OrderType.FindRequiredKey(configurationId, "orderTypeCode", externalOrderTypeCode);
            int priceTypeCode = PriceType.FindRequiredKey(configurationId, "priceTypeCode", externalPriceTypeCode);
            int securityId = Security.FindRequiredKey(configurationId, "securityId", externalSecurityId);
            object settlementId = Security.FindOptionalKey(configurationId, "settlementId", externalSettlementId);
            int sourceOrderId = SourceOrder.FindKey(configurationId, "sourceOrderId", externalSourceOrderId);
            int statusCode = Status.FindRequiredKey(configurationId, "statusCode", externalStatusCode);
            int timeInForceCode = TimeInForce.FindRequiredKey(configurationId, "timeInForceCode", externalTimeInForceCode);
            int workingOrderId = WorkingOrder.FindRequiredKey(configurationId, "workingOrderId", externalWorkingOrderId);
            // The load operation will create a record if it doesn't exist, or update an existing record.  The external
            // identifier is used to determine if a record exists with the same key.
            if ((sourceOrderId == int.MinValue))
            {
                // Populate the 'externalId' varaibles so that the external identifier can be used to find the row when an
                // external method is called with the same 'configurationId' parameter.
                int externalKeyIndex = SourceOrder.GetExternalKeyIndex(configurationId, "sourceOrderId");
                object[] externalIdArray = new object[1];
                externalIdArray[externalKeyIndex] = externalSourceOrderId;
                externalId0 = externalIdArray[0];
                // Call the internal method to complete the operation.
                MarkThree.Guardian.Core.SourceOrder.Insert(adoTransaction, sqlTransaction, ref rowVersion, createdTime, createdUserId, destinationId, externalId0, isAdvertised, isAutoExecute, isCanceled, isHeld, isSteppedIn, isSubmitted, limitPrice, maximumVolatility, modifiedTime, modifiedUserId, newsFreeTime, orderTypeCode, orderedQuantity, priceTypeCode, receivedTime, securityId, settlementId, startTime, statusCode, stopPrice, stopTime, submittedQuantity, submittedTime, targetPrice, timeInForceCode, workingOrderId);
            }
            else
            {
                // While the optimistic concurrency checking is disabled for the external methods, the internal methods
                // still need to perform the check.  This ncurrency checking logic by finding the current row version to be
                // will bypass the coused when the internal method is called.
                ServerMarketData.SourceOrderRow sourceOrderRow = sourceOrderTable.FindBySourceOrderId(sourceOrderId);
                rowVersion = ((long)(sourceOrderRow[sourceOrderTable.RowVersionColumn]));
                // Call the internal method to complete the operation.
                MarkThree.Guardian.Core.SourceOrder.Update(adoTransaction, sqlTransaction, ref rowVersion, createdTime, createdUserId, destinationId, externalId0, isAdvertised, isAutoExecute, isCanceled, isHeld, isSteppedIn, isSubmitted, limitPrice, maximumVolatility, modifiedTime, modifiedUserId, newsFreeTime, orderTypeCode, orderedQuantity, priceTypeCode, receivedTime, securityId, settlementId, sourceOrderId, startTime, statusCode, stopPrice, stopTime, submittedQuantity, submittedTime, targetPrice, timeInForceCode, workingOrderId);
            }
            // Return values.
            parameters["rowVersion"] = rowVersion;
        }
        
        /// <summary>Collects the table lock request(s) for an 'Update' operation</summary>
        /// <param name="adoTransaction">A collection of table locks required for this operation</param>
        public static void Update(AdoTransaction adoTransaction)
        {
            // Call the internal methods to lock the tables required for an insert or update operation.
            MarkThree.Guardian.Core.SourceOrder.Insert(adoTransaction);
            MarkThree.Guardian.Core.SourceOrder.Update(adoTransaction);
            // These table lock(s) are required for the 'Update' operation.
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.SourceOrderLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.ConfigurationLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.DestinationLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.OrderTypeLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.PriceTypeLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.ObjectLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.SecurityLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.StatusLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.TimeInForceLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.UserLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.WorkingOrderLock);
        }
        
        /// <summary>Updates a SourceOrder record using Metadata Parameters.</summary>
        /// <param name="transaction">Contains the parameters and exceptions for this command.</param>
        public static void Update(ParameterList parameters)
        {
            // Accessor for the SourceOrder Table.
            ServerMarketData.SourceOrderDataTable sourceOrderTable = ServerMarketData.SourceOrder;
            // Extract the parameters from the command batch.
            AdoTransaction adoTransaction = parameters["adoTransaction"];
            SqlTransaction sqlTransaction = parameters["sqlTransaction"];
            object configurationId = parameters["configurationId"].Value;
            object createdTime = parameters["createdTime"].Value;
            object externalCreatedUserId = parameters["createdUserId"].Value;
            object externalDestinationId = parameters["destinationId"].Value;
            object isAdvertised = parameters["isAdvertised"].Value;
            object isAutoExecute = parameters["isAutoExecute"].Value;
            object isCanceled = parameters["isCanceled"].Value;
            object isHeld = parameters["isHeld"].Value;
            object isSteppedIn = parameters["isSteppedIn"].Value;
            object isSubmitted = parameters["isSubmitted"].Value;
            object limitPrice = parameters["limitPrice"].Value;
            object maximumVolatility = parameters["maximumVolatility"].Value;
            object modifiedTime = parameters["modifiedTime"].Value;
            object externalModifiedUserId = parameters["modifiedUserId"].Value;
            object newsFreeTime = parameters["newsFreeTime"].Value;
            object externalOrderTypeCode = parameters["orderTypeCode"].Value;
            object orderedQuantity = parameters["orderedQuantity"].Value;
            object externalPriceTypeCode = parameters["priceTypeCode"].Value;
            object receivedTime = parameters["receivedTime"].Value;
            object externalSecurityId = parameters["securityId"].Value;
            object externalSettlementId = parameters["settlementId"].Value;
            string externalSourceOrderId = ((string)(parameters["sourceOrderId"]));
            object startTime = parameters["startTime"].Value;
            object externalStatusCode = parameters["statusCode"].Value;
            object stopPrice = parameters["stopPrice"].Value;
            object stopTime = parameters["stopTime"].Value;
            object submittedQuantity = parameters["submittedQuantity"].Value;
            object submittedTime = parameters["submittedTime"].Value;
            object targetPrice = parameters["targetPrice"].Value;
            object externalTimeInForceCode = parameters["timeInForceCode"].Value;
            object externalWorkingOrderId = parameters["workingOrderId"].Value;
            // The row versioning is largely disabled for external operations.
            long rowVersion = long.MinValue;
            // Resolve External Identifiers
            object createdUserId = User.FindOptionalKey(configurationId, "createdUserId", externalCreatedUserId);
            object destinationId = Destination.FindOptionalKey(configurationId, "destinationId", externalDestinationId);
            object modifiedUserId = User.FindOptionalKey(configurationId, "modifiedUserId", externalModifiedUserId);
            object orderTypeCode = OrderType.FindOptionalKey(configurationId, "orderTypeCode", externalOrderTypeCode);
            object priceTypeCode = PriceType.FindOptionalKey(configurationId, "priceTypeCode", externalPriceTypeCode);
            object securityId = Security.FindOptionalKey(configurationId, "securityId", externalSecurityId);
            object settlementId = Security.FindOptionalKey(configurationId, "settlementId", externalSettlementId);
            int sourceOrderId = SourceOrder.FindRequiredKey(configurationId, "sourceOrderId", externalSourceOrderId);
            object statusCode = Status.FindOptionalKey(configurationId, "statusCode", externalStatusCode);
            object timeInForceCode = TimeInForce.FindOptionalKey(configurationId, "timeInForceCode", externalTimeInForceCode);
            object workingOrderId = WorkingOrder.FindOptionalKey(configurationId, "workingOrderId", externalWorkingOrderId);
            // While the optimistic concurrency checking is disabled for the external methods, the internal methods
            // still need to perform the check.  This ncurrency checking logic by finding the current row version to be
            // will bypass the coused when the internal method is called.
            ServerMarketData.SourceOrderRow sourceOrderRow = sourceOrderTable.FindBySourceOrderId(sourceOrderId);
            rowVersion = ((long)(sourceOrderRow[sourceOrderTable.RowVersionColumn]));
            // Call the internal method to complete the operation.
            MarkThree.Guardian.Core.SourceOrder.Update(adoTransaction, sqlTransaction, ref rowVersion, createdTime, createdUserId, destinationId, null, isAdvertised, isAutoExecute, isCanceled, isHeld, isSteppedIn, isSubmitted, limitPrice, maximumVolatility, modifiedTime, modifiedUserId, newsFreeTime, orderTypeCode, orderedQuantity, priceTypeCode, receivedTime, securityId, settlementId, sourceOrderId, startTime, statusCode, stopPrice, stopTime, submittedQuantity, submittedTime, targetPrice, timeInForceCode, workingOrderId);
            // Return values.
            parameters["rowVersion"] = rowVersion;
        }
        
        /// <summary>Collects the table lock request(s) for an 'Delete' operation</summary>
        /// <param name="adoTransaction">A collection of table locks required for this operation</param>
        public static void Delete(AdoTransaction adoTransaction)
        {
            // Call the internal methods to lock the tables required for an insert or update operation.
            MarkThree.Guardian.Core.SourceOrder.Delete(adoTransaction);
            // These table lock(s) are required for the 'Delete' operation.
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.SourceOrderLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.ConfigurationLock);
        }
        
        /// <summary>Deletes a SourceOrder record using Metadata Parameters.</summary>
        /// <param name="transaction">Contains the parameters and exceptions for this command.</param>
        public static void Delete(ParameterList parameters)
        {
            // Accessor for the SourceOrder Table.
            ServerMarketData.SourceOrderDataTable sourceOrderTable = ServerMarketData.SourceOrder;
            // Extract the parameters from the command batch.
            AdoTransaction adoTransaction = parameters["adoTransaction"];
            SqlTransaction sqlTransaction = parameters["sqlTransaction"];
            object configurationId = parameters["configurationId"].Value;
            string externalSourceOrderId = parameters["sourceOrderId"];
            // The row versioning is largely disabled for external operations.
            long rowVersion = long.MinValue;
            // Find the internal identifier using the primar key elements.
            // identifier is used to determine if a record exists with the same key.
            int sourceOrderId = SourceOrder.FindRequiredKey(configurationId, "sourceOrderId", externalSourceOrderId);
            // While the optimistic concurrency checking is disabled for the external methods, the internal methods
            // still need to perform the check.  This ncurrency checking logic by finding the current row version to be
            // will bypass the coused when the internal method is called.
            ServerMarketData.SourceOrderRow sourceOrderRow = sourceOrderTable.FindBySourceOrderId(sourceOrderId);
            rowVersion = ((long)(sourceOrderRow[sourceOrderTable.RowVersionColumn]));
            // Call the internal method to complete the operation.
            MarkThree.Guardian.Core.SourceOrder.Delete(adoTransaction, sqlTransaction, rowVersion, sourceOrderId);
        }
        
        /// <summary>Collects the table lock request(s) for an 'Archive' operation</summary>
        /// <param name="adoTransaction">A collection of table locks required for this operation</param>
        public static void Archive(AdoTransaction adoTransaction)
        {
            // Call the internal methods to lock the tables required for an insert or update operation.
            MarkThree.Guardian.Core.SourceOrder.Archive(adoTransaction);
            // These table lock(s) are required for the 'Archive' operation.
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.SourceOrderLock);
            adoTransaction.LockRequests.AddReaderLock(ServerMarketData.ConfigurationLock);
        }
        
        /// <summary>Archives a SourceOrder record using Metadata Parameters.</summary>
        /// <param name="transaction">Contains the parameters and exceptions for this command.</param>
        public static void Archive(ParameterList parameters)
        {
            // Accessor for the SourceOrder Table.
            ServerMarketData.SourceOrderDataTable sourceOrderTable = ServerMarketData.SourceOrder;
            // Extract the parameters from the command batch.
            AdoTransaction adoTransaction = parameters["adoTransaction"];
            SqlTransaction sqlTransaction = parameters["sqlTransaction"];
            object configurationId = parameters["configurationId"].Value;
            string externalSourceOrderId = parameters["sourceOrderId"];
            // The row versioning is largely disabled for external operations.
            long rowVersion = long.MinValue;
            // Find the internal identifier using the primar key elements.
            // identifier is used to determine if a record exists with the same key.
            int sourceOrderId = SourceOrder.FindRequiredKey(configurationId, "sourceOrderId", externalSourceOrderId);
            // While the optimistic concurrency checking is disabled for the external methods, the internal methods
            // still need to perform the check.  This ncurrency checking logic by finding the current row version to be
            // will bypass the coused when the internal method is called.
            ServerMarketData.SourceOrderRow sourceOrderRow = sourceOrderTable.FindBySourceOrderId(sourceOrderId);
            rowVersion = ((long)(sourceOrderRow[sourceOrderTable.RowVersionColumn]));
            // Call the internal method to complete the operation.
            MarkThree.Guardian.Core.SourceOrder.Archive(adoTransaction, sqlTransaction, rowVersion, sourceOrderId);
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
