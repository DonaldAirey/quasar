//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MarkThree.Quasar.External
{
    using MarkThree.Quasar;
    using MarkThree.Quasar.Server;
    using MarkThree;
    using System;
    using System.Collections;
    using System.Data;
    using System.Data.SqlClient;
    
    
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Diagnostics.DebuggerStepThrough()]
    public class Position
    {
        
        /// This value is used to map the object to a persistent storage device.  The parameters for the storage
        /// are found in the configuration file for this service.
        public static string PersistentStore = "Quasar";
        
        /// This member provides access to the in-memory database.
        private static ServerDataModel serverDataModel = new ServerDataModel();
        
        /// <summary>Collects the table lock request(s) for an 'Load' operation</summary>
        /// <param name="adoTransaction">A collection of table locks required for this operation</param>
        public static void Load(AdoTransaction adoTransaction)
        {
            // Call the internal methods to lock the tables required for an insert or update operation.
            MarkThree.Quasar.Core.Position.Insert(adoTransaction);
            MarkThree.Quasar.Core.Position.Update(adoTransaction);
            // These table lock(s) are required for the 'Load' operation.
            adoTransaction.LockRequests.Add(new TableReaderRequest(ServerDataModel.Position));
            adoTransaction.LockRequests.Add(new TableReaderRequest(ServerDataModel.Configuration));
            adoTransaction.LockRequests.Add(new TableReaderRequest(ServerDataModel.Object));
            adoTransaction.LockRequests.Add(new TableReaderRequest(ServerDataModel.Account));
            adoTransaction.LockRequests.Add(new TableReaderRequest(ServerDataModel.PositionType));
            adoTransaction.LockRequests.Add(new TableReaderRequest(ServerDataModel.Security));
        }
        
        /// <summary>Loads a Position record using Metadata Parameters.</summary>
        /// <param name="transaction">Contains the parameters and exceptions for this command.</param>
        public static void Load(ParameterList parameters)
        {
            // Accessor for the Position Table.
            ServerDataModel.PositionDataTable positionTable = ServerDataModel.Position;
            // Extract the parameters from the command batch.
            AdoTransaction adoTransaction = parameters["adoTransaction"];
            SqlTransaction sqlTransaction = parameters["sqlTransaction"];
            object configurationId = parameters["configurationId"].Value;
            string externalAccountId = parameters["accountId"];
            string externalSecurityId = parameters["securityId"];
            string externalPositionTypeCode = parameters["positionTypeCode"];
            object userData0 = parameters["userData0"].Value;
            object userData1 = parameters["userData1"].Value;
            object userData2 = parameters["userData2"].Value;
            object userData3 = parameters["userData3"].Value;
            object userData4 = parameters["userData4"].Value;
            object userData5 = parameters["userData5"].Value;
            object userData6 = parameters["userData6"].Value;
            object userData7 = parameters["userData7"].Value;
            // The row versioning is largely disabled for external operations.
            long rowVersion = long.MinValue;
            // Resolve External Identifiers
            int accountId = Account.FindRequiredKey(configurationId, "accountId", externalAccountId);
            int securityId = Security.FindRequiredKey(configurationId, "securityId", externalSecurityId);
            int positionTypeCode = PositionType.FindRequiredKey(configurationId, "positionTypeCode", externalPositionTypeCode);
            // Find the record using the unique identifier.  If it doesn't exist, it will be inserted, if it does exist,
            // it will be updated.
            ServerDataModel.PositionRow positionRow = positionTable.FindByAccountIdSecurityIdPositionTypeCode(accountId, securityId, positionTypeCode);
            if ((positionRow == null))
            {
                // Call the internal 'Insert' method to complete the operation.
                MarkThree.Quasar.Core.Position.Insert(adoTransaction, sqlTransaction, ref rowVersion, accountId, securityId, positionTypeCode, userData0, userData1, userData2, userData3, userData4, userData5, userData6, userData7);
            }
            else
            {
                // This will bypass the optimistic concurrency checking required by the internal method.
                rowVersion = ((long)(positionRow[positionTable.RowVersionColumn]));
                // Call the internal 'Update' method to complete the operation.
                MarkThree.Quasar.Core.Position.Update(adoTransaction, sqlTransaction, ref rowVersion, accountId, securityId, positionTypeCode, userData0, userData1, userData2, userData3, userData4, userData5, userData6, userData7);
            }
            // Return values
            parameters["rowVersion"] = rowVersion;
        }
        
        /// <summary>Collects the table lock request(s) for an 'Update' operation</summary>
        /// <param name="adoTransaction">A collection of table locks required for this operation</param>
        public static void Update(AdoTransaction adoTransaction)
        {
            // Call the internal methods to lock the tables required for an insert or update operation.
            MarkThree.Quasar.Core.Position.Insert(adoTransaction);
            MarkThree.Quasar.Core.Position.Update(adoTransaction);
            // These table lock(s) are required for the 'Update' operation.
            adoTransaction.LockRequests.Add(new TableReaderRequest(ServerDataModel.Position));
            adoTransaction.LockRequests.Add(new TableReaderRequest(ServerDataModel.Configuration));
            adoTransaction.LockRequests.Add(new TableReaderRequest(ServerDataModel.Object));
            adoTransaction.LockRequests.Add(new TableReaderRequest(ServerDataModel.Account));
            adoTransaction.LockRequests.Add(new TableReaderRequest(ServerDataModel.PositionType));
            adoTransaction.LockRequests.Add(new TableReaderRequest(ServerDataModel.Security));
        }
        
        /// <summary>Updates a Position record using Metadata Parameters.</summary>
        /// <param name="transaction">Contains the parameters and exceptions for this command.</param>
        public static void Update(ParameterList parameters)
        {
            // Accessor for the Position Table.
            ServerDataModel.PositionDataTable positionTable = ServerDataModel.Position;
            // Extract the parameters from the command batch.
            AdoTransaction adoTransaction = parameters["adoTransaction"];
            SqlTransaction sqlTransaction = parameters["sqlTransaction"];
            object configurationId = parameters["configurationId"].Value;
            string externalAccountId = parameters["accountId"];
            string externalSecurityId = parameters["securityId"];
            string externalPositionTypeCode = parameters["positionTypeCode"];
            object userData0 = parameters["userData0"].Value;
            object userData1 = parameters["userData1"].Value;
            object userData2 = parameters["userData2"].Value;
            object userData3 = parameters["userData3"].Value;
            object userData4 = parameters["userData4"].Value;
            object userData5 = parameters["userData5"].Value;
            object userData6 = parameters["userData6"].Value;
            object userData7 = parameters["userData7"].Value;
            // The row versioning is largely disabled for external operations.
            long rowVersion = long.MinValue;
            // Resolve External Identifiers
            int accountId = Account.FindRequiredKey(configurationId, "accountId", externalAccountId);
            int securityId = Security.FindRequiredKey(configurationId, "securityId", externalSecurityId);
            int positionTypeCode = PositionType.FindRequiredKey(configurationId, "positionTypeCode", externalPositionTypeCode);
            // This will bypass the internal optimistic concurrency checking by providing the current rowVersion to the 
            // internal method.
            ServerDataModel.PositionRow positionRow = positionTable.FindByAccountIdSecurityIdPositionTypeCode(accountId, securityId, positionTypeCode);
            rowVersion = ((long)(positionRow[positionTable.RowVersionColumn]));
            // Call the internal method to complete the operation.
            MarkThree.Quasar.Core.Position.Update(adoTransaction, sqlTransaction, ref rowVersion, accountId, securityId, positionTypeCode, userData0, userData1, userData2, userData3, userData4, userData5, userData6, userData7);
            // Return values.
            parameters["rowVersion"] = rowVersion;
        }
        
        /// <summary>Collects the table lock request(s) for an 'Delete' operation</summary>
        /// <param name="adoTransaction">A collection of table locks required for this operation</param>
        public static void Delete(AdoTransaction adoTransaction)
        {
            // Call the internal methods to lock the tables required for an insert or update operation.
            MarkThree.Quasar.Core.Position.Delete(adoTransaction);
            // These table lock(s) are required for the 'Delete' operation.
            adoTransaction.LockRequests.Add(new TableReaderRequest(ServerDataModel.Position));
        }
        
        /// <summary>Deletes a Position record using Metadata Parameters.</summary>
        /// <param name="transaction">Contains the parameters and exceptions for this command.</param>
        public static void Delete(ParameterList parameters)
        {
            // Accessor for the Position Table.
            ServerDataModel.PositionDataTable positionTable = ServerDataModel.Position;
            // Extract the parameters from the command batch.
            AdoTransaction adoTransaction = parameters["adoTransaction"];
            SqlTransaction sqlTransaction = parameters["sqlTransaction"];
            object configurationId = parameters["configurationId"].Value;
            string externalAccountId = parameters["accountId"];
            string externalSecurityId = parameters["securityId"];
            string externalPositionTypeCode = parameters["positionTypeCode"];
            // Resolve External Identifiers
            int accountId = Account.FindRequiredKey(configurationId, "accountId", externalAccountId);
            int securityId = Security.FindRequiredKey(configurationId, "securityId", externalSecurityId);
            int positionTypeCode = PositionType.FindRequiredKey(configurationId, "positionTypeCode", externalPositionTypeCode);
            // The row versioning is largely disabled for external operations.
            long rowVersion = long.MinValue;
            // While the optimistic concurrency checking is disabled for the external methods, the internal methods
            // still need to perform the check.  This ncurrency checking logic by finding the current row version to be
            // will bypass the coused when the internal method is called.
            ServerDataModel.PositionRow positionRow = positionTable.FindByAccountIdSecurityIdPositionTypeCode(accountId, securityId, positionTypeCode);
            rowVersion = ((long)(positionRow[positionTable.RowVersionColumn]));
            // Call the internal method to complete the operation.
            MarkThree.Quasar.Core.Position.Delete(adoTransaction, sqlTransaction, rowVersion, accountId, securityId, positionTypeCode);
        }
        
        /// <summary>Collects the table lock request(s) for an 'Archive' operation</summary>
        /// <param name="adoTransaction">A collection of table locks required for this operation</param>
        public static void Archive(AdoTransaction adoTransaction)
        {
            // Call the internal methods to lock the tables required for an insert or update operation.
            MarkThree.Quasar.Core.Position.Archive(adoTransaction);
            // These table lock(s) are required for the 'Archive' operation.
            adoTransaction.LockRequests.Add(new TableReaderRequest(ServerDataModel.Position));
        }
        
        /// <summary>Archives a Position record using Metadata Parameters.</summary>
        /// <param name="transaction">Contains the parameters and exceptions for this command.</param>
        public static void Archive(ParameterList parameters)
        {
            // Accessor for the Position Table.
            ServerDataModel.PositionDataTable positionTable = ServerDataModel.Position;
            // Extract the parameters from the command batch.
            AdoTransaction adoTransaction = parameters["adoTransaction"];
            SqlTransaction sqlTransaction = parameters["sqlTransaction"];
            object configurationId = parameters["configurationId"].Value;
            string externalAccountId = parameters["accountId"];
            string externalSecurityId = parameters["securityId"];
            string externalPositionTypeCode = parameters["positionTypeCode"];
            // Resolve External Identifiers
            int accountId = Account.FindRequiredKey(configurationId, "accountId", externalAccountId);
            int securityId = Security.FindRequiredKey(configurationId, "securityId", externalSecurityId);
            int positionTypeCode = PositionType.FindRequiredKey(configurationId, "positionTypeCode", externalPositionTypeCode);
            // The row versioning is largely disabled for external operations.
            long rowVersion = long.MinValue;
            // While the optimistic concurrency checking is disabled for the external methods, the internal methods
            // still need to perform the check.  This ncurrency checking logic by finding the current row version to be
            // will bypass the coused when the internal method is called.
            ServerDataModel.PositionRow positionRow = positionTable.FindByAccountIdSecurityIdPositionTypeCode(accountId, securityId, positionTypeCode);
            rowVersion = ((long)(positionRow[positionTable.RowVersionColumn]));
            // Call the internal method to complete the operation.
            MarkThree.Quasar.Core.Position.Archive(adoTransaction, sqlTransaction, rowVersion, accountId, securityId, positionTypeCode);
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ve' operation.
            transaction.Locks.AddReaderLock(ServerDataModel.PositionLock);
        }
        
        /// <summary>Archives a Position record using Metadata Parameters.</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit</param>
        /// <param name="remoteMethod">Contains the parameters and exceptions for this command.</param>
        public static void Archive(Transaction transaction, RemoteMethod remoteMethod)
        {
            try
            {
                // Accessor for the Position Table.
                ServerDataModel.PositionDataTable positionTable = ServerDataModel.Position;
                // Extract the parameters from the command batch.
                string configurationId = remoteMethod.Parameters.GetRequiredString("configurationId", "DEFAULT");
                string externalAccountId = remoteMethod.Parameters.GetRequiredString("accountId");
                string externalSecurityId = remoteMethod.Parameters.GetRequiredString("securityId");
                string externalPositionTypeCode = remoteMethod.Parameters.GetRequiredString("positionTypeCode");
                // Make sure the parameters were parsed correctly before calling the internal method. This will prevent the method
                // from being called with bad data, but provides for error checking on all the parameters.
                if ((remoteMethod.HasExceptions == false))
                {
                    // Resolve External Identifiers
                    int accountId = Account.FindRequiredKey(configurationId, "accountId", externalAccountId);
                    int securityId = Security.FindRequiredKey(configurationId, "securityId", externalSecurityId);
                    int positionTypeCode = PositionType.FindRequiredKey(configurationId, "positionTypeCode", externalPositionTypeCode);
                    // The row versioning is largely disabled for external operations.
                    long rowVersion = long.MinValue;
                    // While the optimistic concurrency checking is disabled for the external methods, the internal methods
                    // still need to perform the check.  This ncurrency checking logic by finding the current row version to be
                    // will bypass the coused when the internal method is called.
                    ServerDataModel.PositionRow positionRow = positionTable.FindByAccountIdSecurityIdPositionTypeCode(accountId, securityId, positionTypeCode);
                    rowVersion = ((long)(positionRow[positionTable.RowVersionColumn]));
                    // Call the internal method to complete the operation.
                    Shadows.WebService.Core.Position.Archive(transaction, accountId, securityId, positionTypeCode, rowVersion);
                }
            }
            catch (SqlException sqlException)
            {
                // Every exception from the SQL server call is packed into the 'RemoteMethod' structure and returned to the caller.
                for (IEnumerator iEnumerator = sqlException.Errors.GetEnumerator(); iEnumerator.MoveNext(); remoteMethod.Exceptions.Add(((SqlError)(iEnumerator.Current)).Message))
                {
                }
            }
            catch (Exception exception)
            {
                // This will pass the general exception back to the caller.
                remoteMethod.Exceptions.Add(exception);
            }
        }
    }
}
