// This module contains a Compliance Rule that will generate violations whenever any of the accounts in the restricted account list
// contain any of the securities in the restricted security list.  The compliance rule is event driven and demonstrates how to
// catch violations at the moment they occur.
namespace Shadows.Quasar.Rule
{

	using System;

	/// <summary>
	/// List of Restricted Securities
	/// </summary>
	internal class AlphaSecurityList : SecurityList
	{

		public AlphaSecurityList()
		{

			// This is the list of securities that are restricted from trading.
			Add(Security.Find("US TICKER", "AHC"));
			Add(Security.Find("US TICKER", "MDS"));
			Add(Security.Find("US TICKER", "SUN"));

		}

	}
	
	/// <summary>
	/// List of Restricted Accounts
	/// </summary>
	internal class AlphaAccountList : AccountList
	{

		public AlphaAccountList()
		{

			// These are the accounts that are restricted from trading.
			Add(Account.Find("0234"));
			Add(Account.Find("0236"));
			Add(Account.Find("0237"));
			Add(Account.Find("0239"));
			Add(Account.Find("0241"));

		}

	}
	
	/// <summary>
	/// A sample compliance rule.  A very simple list of security/account restrictions.
	/// </summary>
	public class AlphaListRule
	{

		// A 'Restriction' is used as part of the key on the violations table.  It identifies the violations that are generated by
		// this rule and keeps them distinct from violations that might occur from some other rule on the same position.
		private static Restriction restriction;
		private static PositionTable alphaPositionTable;
		private static PositionTable updatePositionTable;

		/// <summary>
		/// Install an event driven compliance check and initialize the violations table.
		/// </summary>
		static AlphaListRule()
		{

			// This will create a table of positions for every combination of a restricted securities in a restricted account.  
			// This is just one example of how a set of restricted positions could be created.
			AlphaListRule.alphaPositionTable = new PositionTable(new AlphaAccountList(), new AlphaSecurityList());

			AlphaListRule.updatePositionTable = new PositionTable();

			// This a simple "Restricted Security" compliance check.  If a position exists or is created on the predefined account
			// and security combination, then a 'Violation' record will be created.  Conversely, if those conditions are removed,
			// the corresponding violation will be deleted.  The first parameter to opening up a 'Restriction' is the user-defined
			// name, which must be unique for this rule.  The restriction can specify a severity level and how many overrides are
			// required to allow it to trade.  Also, a message with replacable parameters can be specified here.  When a violation
			// is created, this message and the optional data items are combined to create a specific message for the violation. In
			// this example, the ticker symbol and account name will be filled when the violation is created.
			AlphaListRule.restriction = Restriction.Find("ALPHALIST");
			if (AlphaListRule.restriction == null)
				AlphaListRule.restriction = new Restriction("ALPHALIST", Severity.High, Approval.Officer,
				"Security '{0}' is restricted from account {1}.");

			// The violations need to be synchronized with the current state of the data model when this compliance check is first
			// installed .  That is, since the programming model is event driven, the state of the violations has to be initialized
			// for the incremental rule checking to work.  This step will remove any violations that are no longer valid.
			foreach (Violation violation in restriction.GetViolations())
				if (violation.Position.GetQuantity() == 0.0M)
					violation.Remove();

			// This will complete the task of synchronizing the data model for the compliance rule.  If a non-zero position is
			// found in the list of restricted securities and accounts, a violation on that position will be generated.
			foreach (Position position in AlphaListRule.alphaPositionTable)
			{

				// Create a position object based on the account, security and long or short position type.  Any quantity found for
				// that position will trigger a violation.  Note that if a violation already exists for this restriction and
				// position combination, the description of the violation will be overwritten, but the record will be otherwise
				// unchanged.
				if (position.GetQuantity() != 0.0M)
				{
					Violation violation = Violation.Find(restriction, position);
					if (violation == null)
						Violation.Add(restriction, position, position.Security.Symbol, position.Account.Name);
				}

			}

			// Flush the command buffer.
			CommandBatch.Flush();
			
			// This compliance check is event driven.  When an event -- such as adding or deleting an order -- changes the state of
			// the data model, these tests will be called to insure that the new state doesn't violate this compliance rule.  In
			// the case of a simple list rule, the new position will be tested to see if adding or deleting a position results in a
			// violation.  These statements install the event handlers for tax lots, proposed orders, orders and allocations.  For
			// example, the method 'TaxLotHandler' will be called when the tax lot table changes.
			MarketData.BeginMerge += new EventHandler(BeginMerge);
			TaxLot.Changed += new TaxLotEvent(TaxLotHandler);
			ProposedOrder.Changed += new ProposedOrderEvent(ProposedOrderHandler);
			Order.Changed += new OrderEvent(OrderHandler);
			Allocation.Changed += new AllocationEvent(AllocationHandler);
			MarketData.EndMerge += new EventHandler(EndMerge);

		}

		private static void BeginMerge(object sender, EventArgs eventArgs)
		{

			// Clear the list of modified positions before each merge.  As the tables are synchrnoized with the master tables, the
			// events handlers will be called to process new tax lots, proposed orders, orders and allocations. The event handlers
			// associated with this rule will filter out the positions that are restricted by this rule.  When merging is 
			// complete, the 'EndMerge' will cycle through the collected positions and clear or create violations.
			AlphaListRule.updatePositionTable.Clear();

		}
		
		/// <summary>
		/// Event driven handler for a change to Tax Lots.
		/// </summary>
		/// <param name="sender">The object that originated the event (ignored).</param>
		/// <param name="taxLotEventArgs">The event argument.</param>
		private static void TaxLotHandler(object sender, TaxLotEventArgs taxLotEventArgs)
		{

			// Extract the event argument and call a common method for testing the position against the list rule.
			if (AlphaListRule.alphaPositionTable.Contains(taxLotEventArgs.TaxLot.Position))
				AlphaListRule.updatePositionTable.Add(taxLotEventArgs.TaxLot.Position);

		}

		/// <summary>
		/// Event driven handler for a change to Proposed Orders.
		/// </summary>
		/// <param name="sender">The object that originated the event (ignored).</param>
		/// <param name="proposedOrderEventArgs">The event argument.</param>
		private static void ProposedOrderHandler(object sender, ProposedOrderEventArgs proposedOrderEventArgs)
		{

			// Extract the event argument and call a common method for testing the position against the list rule.
			if (AlphaListRule.alphaPositionTable.Contains(proposedOrderEventArgs.ProposedOrder.Position))
				AlphaListRule.updatePositionTable.Add(proposedOrderEventArgs.ProposedOrder.Position);

		}

		/// <summary>
		/// Event driven handler for a change to Orders.
		/// </summary>
		/// <param name="sender">The object that originated the event (ignored).</param>
		/// <param name="orderEventArgs">The event argument.</param>
		private static void OrderHandler(object sender, OrderEventArgs orderEventArgs)
		{

			// Extract the event argument and call a common method for testing the position against the list rule.
			if (AlphaListRule.alphaPositionTable.Contains(orderEventArgs.Order.Position))
				AlphaListRule.updatePositionTable.Add(orderEventArgs.Order.Position);


		}

		/// <summary>
		/// Event driven handler for a change to Allocations.
		/// </summary>
		/// <param name="sender">The object that originated the event (ignored).</param>
		/// <param name="allocationEventArgs">The event argument.</param>
		private static void AllocationHandler(object sender, AllocationEventArgs allocationEventArgs)
		{

			// Extract the event argument and call a common method for testing the position against the list rule.
			if (AlphaListRule.alphaPositionTable.Contains(allocationEventArgs.Allocation.Position))
				AlphaListRule.updatePositionTable.Add(allocationEventArgs.Allocation.Position);

		}

		/// <summary>
		/// Evaluates a given position for a restricted security.
		/// </summary>
		/// <param name="action">Indicates whether the position is being added, modified or deleted.</param>
		/// <param name="position">An account, security and position type (long or short) combination.</param>
		private static void EndMerge(object sender, EventArgs eventArgs)
		{

			foreach (Position position in AlphaListRule.updatePositionTable)
			{

				Violation violation = Violation.Find(restriction, position);
				if (position.GetQuantity() == 0.0M)
				{
					if (violation != null)
						violation.Remove();
				}
				else
				{
					if (violation == null)
						Violation.Add(restriction, position, position.Security.Symbol, position.Account.Name);
				}

			}

		}

	}

}
