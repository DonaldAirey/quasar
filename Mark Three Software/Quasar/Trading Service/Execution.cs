//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.288
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

namespace Shadows.WebService.Trading
{
    using Shadows.Quasar.Common;
    using Shadows.Quasar.Server;
    using System;
    using System.Collections;
    using System.Data;
    using System.Data.SqlClient;
    
    
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Diagnostics.DebuggerStepThrough()]
    public class Execution
    {
        
        /// <summary>Collects the table lock request(s) for an Insert operation</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit</param>
        public static void Insert(Transaction transaction)
        {
			// These tables are needed for the 'Update' Operation.
			transaction.Locks.AddReaderLock(ServerMarketData.BlockOrderLock);
			transaction.Locks.AddReaderLock(ServerMarketData.OrderLock);
			// Call the base class to lock the tables.
            Shadows.WebService.Core.Execution.Insert(transaction);
        }
        
        /// <summary>Inserts a Execution record using Metadata Parameters.</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit.</param>
        /// <param name="remoteMethod">Contains the metadata parameters and exceptions for this command.</param>
        public static void Insert(Transaction transaction, RemoteMethod remoteMethod)
        {
            try
            {
                // Extract the parameters from the command batch.
                int blockOrderId = remoteMethod.Parameters.GetRequiredInt32("blockOrderId");
                int brokerId = remoteMethod.Parameters.GetRequiredInt32("brokerId");
                System.Decimal quantity = remoteMethod.Parameters.GetRequiredDecimal("quantity");
                System.Decimal price = remoteMethod.Parameters.GetRequiredDecimal("price");
                object commission = remoteMethod.Parameters.GetOptionalDecimal("commission");
                object accruedInterest = remoteMethod.Parameters.GetOptionalDecimal("accruedInterest");
                object userFee0 = remoteMethod.Parameters.GetOptionalDecimal("userFee0");
                object userFee1 = remoteMethod.Parameters.GetOptionalDecimal("userFee1");
                object userFee2 = remoteMethod.Parameters.GetOptionalDecimal("userFee2");
                object userFee3 = remoteMethod.Parameters.GetOptionalDecimal("userFee3");
                System.DateTime tradeDate = remoteMethod.Parameters.GetRequiredDateTime("tradeDate");
                System.DateTime settlementDate = remoteMethod.Parameters.GetRequiredDateTime("settlementDate");
                // Make sure the parameters were parsed correctly before calling the internal method. This will prevent the method
                // from being called with bad data, but provides for error checking on all the parameters.
                if ((remoteMethod.HasExceptions == false))
                {
                    // The rowVersion is passed back to the caller in the event it's needed for additional commands in the batch.
                    long rowVersion = long.MinValue;
                    // Call the internal method to complete the operation.
                    int executionId = Execution.Insert(transaction, blockOrderId, brokerId, ref rowVersion, quantity, price, commission, accruedInterest, userFee0, userFee1, userFee2, userFee3, tradeDate, settlementDate);
                    // Return values.
                    remoteMethod.Parameters.ReturnValue("rowVersion", rowVersion);
                    remoteMethod.Parameters.ReturnValue(executionId);
                }
            }
            catch (SqlException sqlException)
            {
                // Every exception from the SQL server call is packed into the 'RemoteMethod' structure and returned to the caller.
                for (IEnumerator iEnumerator = sqlException.Errors.GetEnumerator(); iEnumerator.MoveNext(); remoteMethod.Exceptions.Add(((SqlError)(iEnumerator.Current)).Message))
                {
                }
            }
            catch (Exception exception)
            {
                // This will pass the general exception back to the caller.
                remoteMethod.Exceptions.Add(exception);
            }
        }
        
        /// <summary>Inserts a Execution record.</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit</param>
        /// <param name="blockOrderId">The value for the BlockOrderId column.</param>
        /// <param name="brokerId">The value for the BrokerId column.</param>
        /// <param name="rowVersion">The value for the RowVersion column.</param>
        /// <param name="quantity">The value for the Quantity column.</param>
        /// <param name="price">The value for the Price column.</param>
        /// <param name="commission">The value for the Commission column.</param>
        /// <param name="accruedInterest">The value for the AccruedInterest column.</param>
        /// <param name="userFee0">The value for the UserFee0 column.</param>
        /// <param name="userFee1">The value for the UserFee1 column.</param>
        /// <param name="userFee2">The value for the UserFee2 column.</param>
        /// <param name="userFee3">The value for the UserFee3 column.</param>
        /// <param name="tradeDate">The value for the TradeDate column.</param>
        /// <param name="settlementDate">The value for the SettlementDate column.</param>
        public static int Insert(
                    Transaction transaction, 
                    int blockOrderId, 
                    int brokerId, 
                    ref long rowVersion, 
                    System.Decimal quantity, 
                    System.Decimal price, 
                    object commission, 
                    object accruedInterest, 
                    object userFee0, 
                    object userFee1, 
                    object userFee2, 
                    object userFee3, 
                    System.DateTime tradeDate, 
                    System.DateTime settlementDate)
        {

			// Provide the created time and current user id to the base class.
			int createdLoginId = ServerMarketData.LoginId;
            DateTime createdTime = DateTime.Now;

			// Rule #1: The block order exist.
			ServerMarketData.BlockOrderRow blockOrderRow = ServerMarketData.BlockOrder.FindByBlockOrderId(blockOrderId);
			if (blockOrderRow == null)
				throw new Exception("This block order has been deleted by someone else");

			// Rule #2: The Block Order is active
			if (blockOrderRow.StatusCode == Shadows.Quasar.Common.Status.Closed ||
				blockOrderRow.StatusCode == Shadows.Quasar.Common.Status.Confirmed ||
				blockOrderRow.StatusCode == Shadows.Quasar.Common.Status.Pending)
				throw new Exception("This order isn't active");

			// Rule #3: Quantity executed doesn't exceed the quantity ordered.
			decimal quantityOrdered = 0.0M;
			foreach (ServerMarketData.OrderRow orderSumRow in blockOrderRow.GetOrderRows())
				quantityOrdered += orderSumRow.Quantity;
			decimal quantityExecuted = 0.0M;
			foreach (ServerMarketData.ExecutionRow executionSumRow in blockOrderRow.GetExecutionRows())
				quantityExecuted += executionSumRow.Quantity;
			if (quantityExecuted + quantity > quantityOrdered)
				throw new Exception("The quantity placed is more than the quantity ordered.");

			// Call the base class to insert the execution.
			return Shadows.WebService.Core.Execution.Insert(transaction, blockOrderId, brokerId, ref rowVersion, null, quantity, price,
				commission, accruedInterest, userFee0, userFee1, userFee2, userFee3, tradeDate, settlementDate, createdTime,
				createdLoginId, createdTime, createdLoginId);

		}
        
        /// <summary>Collects the table lock request(s) for an Update operation</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit</param>
        public static void Update(Transaction transaction)
        {
			// These tables are needed for the 'Update' Operation.
			transaction.Locks.AddReaderLock(ServerMarketData.BlockOrderLock);
			transaction.Locks.AddReaderLock(ServerMarketData.OrderLock);
			// Call the base class to lock the tables.
			Shadows.WebService.Core.Execution.Update(transaction);
		}
        
        /// <summary>Updates a Execution record using Metadata Parameters.</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit</param>
        /// <param name="remoteMethod">Contains the parameters and exceptions for this command.</param>
        public static void Update(Transaction transaction, RemoteMethod remoteMethod)
        {
            try
            {
                // Extract the parameters from the command batch.
                int executionId = remoteMethod.Parameters.GetRequiredInt32("executionId");
                object blockOrderId = remoteMethod.Parameters.GetOptionalInt32("blockOrderId");
                object brokerId = remoteMethod.Parameters.GetOptionalInt32("brokerId");
                long rowVersion = remoteMethod.Parameters.GetRequiredInt64("rowVersion");
                object quantity = remoteMethod.Parameters.GetOptionalDecimal("quantity");
                object price = remoteMethod.Parameters.GetOptionalDecimal("price");
                object commission = remoteMethod.Parameters.GetOptionalDecimal("commission");
                object accruedInterest = remoteMethod.Parameters.GetOptionalDecimal("accruedInterest");
                object userFee0 = remoteMethod.Parameters.GetOptionalDecimal("userFee0");
                object userFee1 = remoteMethod.Parameters.GetOptionalDecimal("userFee1");
                object userFee2 = remoteMethod.Parameters.GetOptionalDecimal("userFee2");
                object userFee3 = remoteMethod.Parameters.GetOptionalDecimal("userFee3");
                object tradeDate = remoteMethod.Parameters.GetOptionalDateTime("tradeDate");
                object settlementDate = remoteMethod.Parameters.GetOptionalDateTime("settlementDate");
                // Make sure the parameters were parsed correctly before calling the internal method. This will prevent the method
                // from being called with bad data, but provides for error checking on all the parameters.
                if ((remoteMethod.HasExceptions == false))
                {
                    // Call the internal method to complete the operation.
                    Execution.Update(transaction, executionId, blockOrderId, brokerId, ref rowVersion, quantity, price, commission, accruedInterest, userFee0, userFee1, userFee2, userFee3, tradeDate, settlementDate);
                    // Return values.
                    remoteMethod.Parameters.ReturnValue("rowVersion", rowVersion);
                }
            }
            catch (SqlException sqlException)
            {
                // Every exception from the SQL server call is packed into the 'RemoteMethod' structure and returned to the caller.
                for (IEnumerator iEnumerator = sqlException.Errors.GetEnumerator(); iEnumerator.MoveNext(); remoteMethod.Exceptions.Add(((SqlError)(iEnumerator.Current)).Message))
                {
                }
            }
            catch (Exception exception)
            {
                // This will pass the general exception back to the caller.
                remoteMethod.Exceptions.Add(exception);
            }
        }
        
        /// <summary>Updates a Execution record.</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit</param>
        /// <param name="executionId">The value for the ExecutionId column.</param>
        /// <param name="blockOrderId">The value for the BlockOrderId column.</param>
        /// <param name="brokerId">The value for the BrokerId column.</param>
        /// <param name="rowVersion">The value for the RowVersion column.</param>
        /// <param name="quantity">The value for the Quantity column.</param>
        /// <param name="price">The value for the Price column.</param>
        /// <param name="commission">The value for the Commission column.</param>
        /// <param name="accruedInterest">The value for the AccruedInterest column.</param>
        /// <param name="userFee0">The value for the UserFee0 column.</param>
        /// <param name="userFee1">The value for the UserFee1 column.</param>
        /// <param name="userFee2">The value for the UserFee2 column.</param>
        /// <param name="userFee3">The value for the UserFee3 column.</param>
        /// <param name="tradeDate">The value for the TradeDate column.</param>
        /// <param name="settlementDate">The value for the SettlementDate column.</param>
        public static void Update(
                    Transaction transaction, 
                    int executionId, 
                    object blockOrderId, 
                    object brokerId, 
                    ref long rowVersion, 
                    object quantity, 
                    object price, 
                    object commission, 
                    object accruedInterest, 
                    object userFee0, 
                    object userFee1, 
                    object userFee2, 
                    object userFee3, 
                    object tradeDate, 
                    object settlementDate)
        {

			// Provide the modified time and current user id to the base class.
			int modifiedLoginId = ServerMarketData.LoginId;
			DateTime modifiedTime = DateTime.Now;

			// Rule #1: Make sure the record exists before updating it.
			ServerMarketData.ExecutionRow executionRow = ServerMarketData.Execution.FindByExecutionId(executionId);
			if ((executionRow == null))
				throw new Exception("This Execution has been deleted by someone else");

			// Rule #2: The block order exist.
			ServerMarketData.BlockOrderRow blockOrderRow = ServerMarketData.BlockOrder.FindByBlockOrderId((int)blockOrderId);
			if (blockOrderRow == null)
				throw new Exception("This block order has been deleted by someone else");

			// Rule #3: The Block Order is active
			if (blockOrderRow.StatusCode == Shadows.Quasar.Common.Status.Closed ||
				blockOrderRow.StatusCode == Shadows.Quasar.Common.Status.Confirmed ||
				blockOrderRow.StatusCode == Shadows.Quasar.Common.Status.Pending)
				throw new Exception("This order isn't active");

			// Rule #4: Quantity executed doesn't exceed the quantity ordered.
			decimal quantityOrdered = 0.0M;
			foreach (ServerMarketData.OrderRow orderSumRow in blockOrderRow.GetOrderRows())
				quantityOrdered += orderSumRow.Quantity;
			decimal quantityPlaced = 0.0M;
			foreach (ServerMarketData.ExecutionRow executionSumRow in blockOrderRow.GetExecutionRows())
				quantityPlaced += executionSumRow.Quantity;
			if (quantityPlaced - executionRow.Quantity + (decimal)quantity > quantityOrdered)
				throw new Exception("The quantity placed is more than the quantity ordered.");

			// Call the base class to insert the execution.
			Shadows.WebService.Core.Execution.Update(transaction, executionId, blockOrderId, brokerId, ref rowVersion, null, quantity,
				price, commission, accruedInterest, userFee0, userFee1, userFee2, userFee3, tradeDate, settlementDate, null, null,
				modifiedTime, modifiedLoginId);
		}
        
        /// <summary>Collects the table lock request(s) for an Delete operation</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit</param>
        public static void Delete(Transaction transaction)
        {
			// Call the base class to lock the tables.
			Shadows.WebService.Core.Execution.Delete(transaction);
		}
        
        /// <summary>Deletes a Execution record using Metadata Parameters.</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit</param>
        /// <param name="remoteMethod">Contains the parameters and exceptions for this command.</param>
        public static void Delete(Transaction transaction, RemoteMethod remoteMethod)
        {
            try
            {
                // Extract the parameters from the command batch.
                int executionId = remoteMethod.Parameters.GetRequiredInt32("executionId");
                long rowVersion = remoteMethod.Parameters.GetRequiredInt64("rowVersion");
                // Make sure the parameters were parsed correctly before calling the internal method. This will prevent the method
                // from being called with bad data, but provides for error checking on all the parameters.
                if ((remoteMethod.HasExceptions == false))
                {
                    // Call the internal method to complete the operation.
                    Execution.Delete(transaction, executionId, rowVersion);
                }
            }
            catch (SqlException sqlException)
            {
                // Every exception from the SQL server call is packed into the 'RemoteMethod' structure and returned to the caller.
                for (IEnumerator iEnumerator = sqlException.Errors.GetEnumerator(); iEnumerator.MoveNext(); remoteMethod.Exceptions.Add(((SqlError)(iEnumerator.Current)).Message))
                {
                }
            }
            catch (Exception exception)
            {
                // This will pass the general exception back to the caller.
                remoteMethod.Exceptions.Add(exception);
            }
        }
        
        /// <summary>Deletes a Execution record.</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit</param>
        /// <param name="executionId">The value for the ExecutionId column.</param>
        /// <param name="rowVersion">The value for the RowVersion column.</param>
        public static void Delete(Transaction transaction, int executionId, long rowVersion)
        {
            // Accessor for the Execution Table.
            ServerMarketData.ExecutionDataTable executionTable = ServerMarketData.Execution;
            // Rule #1: Make sure the record exists before updating it.
            ServerMarketData.ExecutionRow executionRow = executionTable.FindByExecutionId(executionId);
            if ((executionRow == null))
            {
                throw new Exception(string.Format("The Execution table does not have an element identified by {0}", executionId));
            }
            // Rule #2: Optimistic Concurrency Check
            if ((executionRow.RowVersion != rowVersion))
            {
                throw new System.Exception("This record is busy.  Please try again later.");
            }
			// Provide the modified time and current user id to the base class.
			int modifiedLoginId = ServerMarketData.LoginId;
			DateTime modifiedTime = DateTime.Now;
			// Delete the child records.
            // Delete the record in the ADO database.
            transaction.DataRows.Add(executionRow);
            executionRow.Delete();
			// Delete the record in the SQL database.
            SqlCommand updateCommand = new SqlCommand(@"update ""Execution"" set ""ModifiedTime""=@modifiedTime,""ModifiedLoginId""=@modifiedLoginId where ""ExecutionId""=@executionId");
			updateCommand.Connection = transaction.SqlConnection;
			updateCommand.Transaction = transaction.SqlTransaction;
			updateCommand.Parameters.Add("@executionId", @executionId);
			updateCommand.Parameters.Add("@modifiedTime", modifiedTime);
			updateCommand.Parameters.Add("@modifiedLoginId", modifiedLoginId);
			updateCommand.ExecuteNonQuery();
			// Delete the record in the SQL database.
            SqlCommand deleteCommand = new SqlCommand(@"delete ""Execution"" where ""ExecutionId""=@executionId");
            deleteCommand.Connection = transaction.SqlConnection;
            deleteCommand.Transaction = transaction.SqlTransaction;
            deleteCommand.Parameters.Add("@executionId", @executionId);
            deleteCommand.ExecuteNonQuery();
        }
        
    }

}
