//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.288
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

namespace Shadows.WebService.Trading
{
    using Shadows.Quasar.Common;
    using Shadows.Quasar.Server;
	using Shadows.WebService;
    using System;
    using System.Collections;
    using System.Data;
    using System.Data.SqlClient;
    
    
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Diagnostics.DebuggerStepThrough()]
    public class Order
    {
        
        /// <summary>Collects the table lock request(s) for an Insert operation</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit</param>
        public static void Insert(Transaction transaction)
        {

			// These methods are called during the processing of this operation.
			Shadows.WebService.Core.Order.Insert(transaction);
			BlockOrder.Open(transaction);
			
			// Additionally, these tables are required to look up the default blotter.
			transaction.Locks.AddReaderLock(ServerMarketData.BlotterMapLock);
			transaction.Locks.AddReaderLock(ServerMarketData.SecurityLock);

		}
        
        /// <summary>Inserts a Order record using Metadata Parameters.</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit.</param>
        /// <param name="remoteMethod">Contains the metadata parameters and exceptions for this command.</param>
        public static void Insert(Transaction transaction, RemoteMethod remoteMethod)
        {
            try
            {
                // Extract the parameters from the command batch.
				object blockOrderId = remoteMethod.Parameters.GetOptionalInt32("blockOrderId");
				object blotterId = remoteMethod.Parameters.GetOptionalInt32("blotterId");
				int accountId = remoteMethod.Parameters.GetRequiredInt32("accountId");
                int securityId = remoteMethod.Parameters.GetRequiredInt32("securityId");
                int settlementId = remoteMethod.Parameters.GetRequiredInt32("settlementId");
				object brokerId = remoteMethod.Parameters.GetOptionalInt32("brokerId");
                int transactionTypeCode = remoteMethod.Parameters.GetRequiredInt32("transactionTypeCode");
                int timeInForceCode = remoteMethod.Parameters.GetRequiredInt32("timeInForceCode");
                int orderTypeCode = remoteMethod.Parameters.GetRequiredInt32("orderTypeCode");
                object conditionCode = remoteMethod.Parameters.GetOptionalInt32("conditionCode");
                object isAgency = remoteMethod.Parameters.GetOptionalBoolean("isAgency");
                System.Decimal quantity = remoteMethod.Parameters.GetRequiredDecimal("quantity");
                object price1 = remoteMethod.Parameters.GetOptionalDecimal("price1");
                object price2 = remoteMethod.Parameters.GetOptionalDecimal("price2");
                object note = remoteMethod.Parameters.GetOptionalString("note");
                // Make sure the parameters were parsed correctly before calling the internal method. This will prevent the method
                // from being called with bad data, but provides for error checking on all the parameters.
                if ((remoteMethod.HasExceptions == false))
                {
                    // The rowVersion is passed back to the caller in the event it's needed for additional commands in the batch.
                    long rowVersion = long.MinValue;
                    // Call the internal method to complete the operation.
                    int orderId = Order.Insert(transaction, blockOrderId, blotterId, accountId, securityId, settlementId, brokerId, transactionTypeCode, timeInForceCode, orderTypeCode, conditionCode, ref rowVersion, isAgency, quantity, price1, price2, note);
                    // Return values.
                    remoteMethod.Parameters.ReturnValue("rowVersion", rowVersion);
                    remoteMethod.Parameters.ReturnValue(orderId);
                }
            }
            catch (SqlException sqlException)
            {
                // Every exception from the SQL server call is packed into the 'RemoteMethod' structure and returned to the caller.
                for (IEnumerator iEnumerator = sqlException.Errors.GetEnumerator(); iEnumerator.MoveNext(); remoteMethod.Exceptions.Add(((SqlError)(iEnumerator.Current)).Message))
                {
                }
            }
            catch (Exception exception)
            {
                // This will pass the general exception back to the caller.
                remoteMethod.Exceptions.Add(exception);
            }
        }
        
        /// <summary>Inserts a Order record.</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit</param>
        /// <param name="blockOrderId">The value for the BlockOrderId column.</param>
        /// <param name="accountId">The value for the AccountId column.</param>
        /// <param name="securityId">The value for the SecurityId column.</param>
        /// <param name="settlementId">The value for the SettlementId column.</param>
        /// <param name="brokerId">The value for the BrokerId column.</param>
        /// <param name="transactionTypeCode">The value for the TransactionTypeCode column.</param>
        /// <param name="timeInForceCode">The value for the TimeInForceCode column.</param>
        /// <param name="orderTypeCode">The value for the OrderTypeCode column.</param>
        /// <param name="conditionCode">The value for the ConditionCode column.</param>
        /// <param name="rowVersion">The value for the RowVersion column.</param>
        /// <param name="isAgency">The value for the Agency column.</param>
        /// <param name="quantity">The value for the Quantity column.</param>
        /// <param name="price1">The value for the Price1 column.</param>
        /// <param name="price2">The value for the Price2 column.</param>
        /// <param name="note">The value for the Note column.</param>
        /// <param name="createdTime">The value for the CreatedTime column.</param>
        /// <param name="createdLoginId">The value for the CreatedLoginId column.</param>
        /// <param name="modifiedTime">The value for the ModifiedTime column.</param>
        /// <param name="modifiedLoginId">The value for the ModifiedLoginId column.</param>
		public static int Insert(
			Transaction transaction,
			object blockOrderId,
			object blotterId,
			int accountId, 
			int securityId, 
			int settlementId, 
			object brokerId, 
			int transactionTypeCode, 
			int timeInForceCode, 
			int orderTypeCode, 
			object conditionCode, 
			ref long rowVersion, 
			object isAgency, 
			System.Decimal quantity, 
			object price1, 
			object price2, 
			object note)
		{

			// The rowVersion of the block order is declared here, but it is not passed back to the caller.
			long rowVersionBlockOrder = long.MinValue;

			// This will find a block order for the order, or create a block order if one is needed.  The order must be associated
			// with a block at all times.
			if (blockOrderId == null)
			{

				// If the blotter wasn't provided, then find a blotter using the mapping of securities to blotters.
				if (blotterId == null)
				{
					ServerMarketData.SecurityRow securityRow = ServerMarketData.Security.FindBySecurityId(securityId);
					if (securityRow == null)
						throw new Exception(string.Format("Security {0} does not exist", securityId));
					blotterId = TradingSupport.AutoRoute(securityRow, quantity);
				}
				
				// If the order hasn't been associated with a block order yet, then find open one up.  The 'Open' method will 
				// either return a block that matches the attributes of the order -- and can still be blocked -- or it will create
				// a new block based on the attributes of this new order.
				blockOrderId = Shadows.WebService.Trading.BlockOrder.Open(transaction, (int)blotterId, accountId, securityId,
					settlementId, brokerId, transactionTypeCode, timeInForceCode, orderTypeCode, conditionCode,
					ref rowVersionBlockOrder, isAgency, price1, price2);

			}

			// These values are provided by the server.
			int positionTypeCode = 	Shadows.Quasar.Common.TransactionType.GetPosition(transactionTypeCode);
			DateTime createdTime = DateTime.Now;
			int createdLoginId = ServerMarketData.LoginId;

			// Call the internal method to add the order.
			return Shadows.WebService.Core.Order.Insert(transaction, (int)blockOrderId, accountId, securityId, settlementId, brokerId,
				positionTypeCode, transactionTypeCode, timeInForceCode, orderTypeCode, conditionCode, ref rowVersion, null, null,
				quantity, price1, price2, note, createdTime, createdLoginId, createdTime, createdLoginId);

        }
        
        /// <summary>Collects the table lock request(s) for an Update operation</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit</param>
        public static void Update(Transaction transaction)
        {
            // These table lock(s) are required for the 'Update' operation.
            transaction.Locks.AddWriterLock(ServerMarketData.OrderLock);
        }
        
        /// <summary>Updates a Order record using Metadata Parameters.</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit</param>
        /// <param name="remoteMethod">Contains the parameters and exceptions for this command.</param>
        public static void Update(Transaction transaction, RemoteMethod remoteMethod)
        {
            try
            {
                // Extract the parameters from the command batch.
                int orderId = remoteMethod.Parameters.GetRequiredInt32("orderId");
                object blockOrderId = remoteMethod.Parameters.GetOptionalInt32("blockOrderId");
                object accountId = remoteMethod.Parameters.GetOptionalInt32("accountId");
                object securityId = remoteMethod.Parameters.GetOptionalInt32("securityId");
                object settlementId = remoteMethod.Parameters.GetOptionalInt32("settlementId");
                object brokerId = remoteMethod.Parameters.GetOptionalInt32("brokerId");
                object transactionTypeCode = remoteMethod.Parameters.GetOptionalInt32("transactionTypeCode");
                object timeInForceCode = remoteMethod.Parameters.GetOptionalInt32("timeInForceCode");
                object orderTypeCode = remoteMethod.Parameters.GetOptionalInt32("orderTypeCode");
                object conditionCode = remoteMethod.Parameters.GetOptionalInt32("conditionCode");
                long rowVersion = remoteMethod.Parameters.GetRequiredInt64("rowVersion");
                object isAgency = remoteMethod.Parameters.GetOptionalBoolean("isAgency");
                object quantity = remoteMethod.Parameters.GetOptionalDecimal("quantity");
                object price1 = remoteMethod.Parameters.GetOptionalDecimal("price1");
                object price2 = remoteMethod.Parameters.GetOptionalDecimal("price2");
                object note = remoteMethod.Parameters.GetOptionalString("note");
                // Make sure the parameters were parsed correctly before calling the internal method. This will prevent the method
                // from being called with bad data, but provides for error checking on all the parameters.
                if ((remoteMethod.HasExceptions == false))
                {
                    // Call the internal method to complete the operation.
                    Order.Update(transaction, orderId, blockOrderId, accountId, securityId, settlementId, brokerId, transactionTypeCode, timeInForceCode, orderTypeCode, conditionCode, ref rowVersion, isAgency, quantity, price1, price2, note);
                    // Return values.
                    remoteMethod.Parameters.ReturnValue("rowVersion", rowVersion);
                }
            }
            catch (SqlException sqlException)
            {
                // Every exception from the SQL server call is packed into the 'RemoteMethod' structure and returned to the caller.
                for (IEnumerator iEnumerator = sqlException.Errors.GetEnumerator(); iEnumerator.MoveNext(); remoteMethod.Exceptions.Add(((SqlError)(iEnumerator.Current)).Message))
                {
                }
            }
            catch (Exception exception)
            {
                // This will pass the general exception back to the caller.
                remoteMethod.Exceptions.Add(exception);
            }
        }
        
        /// <summary>Updates a Order record.</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit</param>
        /// <param name="orderId">The value for the OrderId column.</param>
        /// <param name="blockOrderId">The value for the BlockOrderId column.</param>
        /// <param name="accountId">The value for the AccountId column.</param>
        /// <param name="securityId">The value for the SecurityId column.</param>
        /// <param name="settlementId">The value for the SettlementId column.</param>
        /// <param name="brokerId">The value for the BrokerId column.</param>
        /// <param name="transactionTypeCode">The value for the TransactionTypeCode column.</param>
        /// <param name="timeInForceCode">The value for the TimeInForceCode column.</param>
        /// <param name="orderTypeCode">The value for the OrderTypeCode column.</param>
        /// <param name="conditionCode">The value for the ConditionCode column.</param>
        /// <param name="rowVersion">The value for the RowVersion column.</param>
        /// <param name="isAgency">The value for the Agency column.</param>
        /// <param name="quantity">The value for the Quantity column.</param>
        /// <param name="price1">The value for the Price1 column.</param>
        /// <param name="price2">The value for the Price2 column.</param>
        /// <param name="note">The value for the Note column.</param>
        public static void Update(
                    Transaction transaction, 
                    int orderId, 
                    object blockOrderId, 
                    object accountId, 
                    object securityId, 
                    object settlementId, 
                    object brokerId, 
                    object transactionTypeCode, 
                    object timeInForceCode, 
                    object orderTypeCode, 
                    object conditionCode, 
                    ref long rowVersion, 
                    object isAgency, 
                    object quantity, 
                    object price1, 
                    object price2, 
                    object note)
        {

			// These values are provided by the server.
			
			object positionTypeCode = transactionTypeCode == null ? (object)null :
				Shadows.Quasar.Common.TransactionType.GetPosition((int)transactionTypeCode);
			DateTime createdTime = DateTime.Now;
			int createdLoginId = ServerMarketData.LoginId;

			// Call the internal method to complete the operation.
			WebService.Core.Order.Update(transaction, orderId, blockOrderId, accountId, securityId, settlementId, brokerId,
				positionTypeCode, transactionTypeCode, timeInForceCode, orderTypeCode, conditionCode, ref rowVersion, null,
				isAgency, quantity, price1, price2, note, createdTime, createdLoginId, createdTime, createdLoginId);

		}
        
        /// <summary>Collects the table lock request(s) for an Delete operation</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit</param>
        public static void Delete(Transaction transaction)
        {
            // These table lock(s) are required for the 'Delete' operation.
            transaction.Locks.AddWriterLock(ServerMarketData.OrderLock);
            transaction.Locks.AddWriterLock(ServerMarketData.OrderTreeLock);
        }
        
        /// <summary>Deletes a Order record using Metadata Parameters.</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit</param>
        /// <param name="remoteMethod">Contains the parameters and exceptions for this command.</param>
        public static void Delete(Transaction transaction, RemoteMethod remoteMethod)
        {
            try
            {
                // Extract the parameters from the command batch.
                int orderId = remoteMethod.Parameters.GetRequiredInt32("orderId");
                long rowVersion = remoteMethod.Parameters.GetRequiredInt64("rowVersion");
                // Make sure the parameters were parsed correctly before calling the internal method. This will prevent the method
                // from being called with bad data, but provides for error checking on all the parameters.
                if ((remoteMethod.HasExceptions == false))
                {
                    // Call the internal method to complete the operation.
                    Order.Delete(transaction, orderId, rowVersion);
                }
            }
            catch (SqlException sqlException)
            {
                // Every exception from the SQL server call is packed into the 'RemoteMethod' structure and returned to the caller.
                for (IEnumerator iEnumerator = sqlException.Errors.GetEnumerator(); iEnumerator.MoveNext(); remoteMethod.Exceptions.Add(((SqlError)(iEnumerator.Current)).Message))
                {
                }
            }
            catch (Exception exception)
            {
                // This will pass the general exception back to the caller.
                remoteMethod.Exceptions.Add(exception);
            }
        }
        
        /// <summary>Deletes a Order record.</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit</param>
        /// <param name="orderId">The value for the OrderId column.</param>
        /// <param name="rowVersion">The value for the RowVersion column.</param>
        public static void Delete(Transaction transaction, int orderId, long rowVersion)
        {

			// These values are provided by the server.
			DateTime modifiedTime = DateTime.Now;
			int modifiedLoginId = ServerMarketData.LoginId;

			// Record the user id and the time of deletion in the record and delete it.
			Shadows.WebService.Core.Order.Update(transaction, orderId, null, null, null, null, null, null, null, null, null, null, ref rowVersion, true, null, null, null,
				null, null, null, null, modifiedTime, modifiedLoginId);
			Shadows.WebService.Core.Order.Delete(transaction, orderId, rowVersion);

		}
        
        /// <summary>Collects the table lock request(s) for an Archive operation</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit</param>
        public static void Archive(Transaction transaction)
        {
            // These table lock(s) are required for the 'Archive' operation.
            transaction.Locks.AddWriterLock(ServerMarketData.OrderLock);
            transaction.Locks.AddWriterLock(ServerMarketData.OrderTreeLock);
        }
        
        /// <summary>Archives a Order record using Metadata Parameters.</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit</param>
        /// <param name="remoteMethod">Contains the parameters and exceptions for this command.</param>
        public static void Archive(Transaction transaction, RemoteMethod remoteMethod)
        {
            try
            {
                // Extract the parameters from the command batch.
                int orderId = remoteMethod.Parameters.GetRequiredInt32("orderId");
                long rowVersion = remoteMethod.Parameters.GetRequiredInt64("rowVersion");
                // Make sure the parameters were parsed correctly before calling the internal method. This will prevent the method
                // from being called with bad data, but provides for error checking on all the parameters.
                if ((remoteMethod.HasExceptions == false))
                {
                    // Call the internal method to complete the operation.
                    Order.Archive(transaction, orderId, rowVersion);
                }
            }
            catch (SqlException sqlException)
            {
                // Every exception from the SQL server call is packed into the 'RemoteMethod' structure and returned to the caller.
                for (IEnumerator iEnumerator = sqlException.Errors.GetEnumerator(); iEnumerator.MoveNext(); remoteMethod.Exceptions.Add(((SqlError)(iEnumerator.Current)).Message))
                {
                }
            }
            catch (Exception exception)
            {
                // This will pass the general exception back to the caller.
                remoteMethod.Exceptions.Add(exception);
            }
        }
        
        /// <summary>Archives a Order record.</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit</param>
        /// <param name="orderId">The value for the OrderId column.</param>
        /// <param name="rowVersion">The value for the RowVersion column.</param>
        /// <param name="archive">true to archive the object, false to unarchive it.</param>
        public static void Archive(Transaction transaction, int orderId, long rowVersion)
        {
            // Accessor for the Order Table.
            ServerMarketData.OrderDataTable orderTable = ServerMarketData.Order;
            // Rule #1: Make sure the record exists before updating it.
            ServerMarketData.OrderRow orderRow = orderTable.FindByOrderId(orderId);
            if ((orderRow == null))
            {
                throw new Exception(string.Format("The Order table does not have an element identified by {0}", orderId));
            }
            // Rule #2: Optimistic Concurrency Check
            if ((orderRow.RowVersion != rowVersion))
            {
                throw new System.Exception("This record is busy.  Please try again later.");
            }
            // Archive the child records.
            for (int index = 0; (index < orderRow.GetOrderTreeRowsByFKOrderOrderTreeChildId().Length); index = index)
            {
                ServerMarketData.OrderTreeRow orderTreeRow = orderRow.GetOrderTreeRowsByFKOrderOrderTreeChildId()[index];
                Core.OrderTree.Archive(transaction, orderTreeRow.ParentId, orderTreeRow.ChildId, orderTreeRow.RowVersion);
            }
            for (int index = 0; (index < orderRow.GetOrderTreeRowsByFKOrderOrderTreeParentId().Length); index = index)
            {
                ServerMarketData.OrderTreeRow orderTreeRow = orderRow.GetOrderTreeRowsByFKOrderOrderTreeParentId()[index];
                Core.OrderTree.Archive(transaction, orderTreeRow.ParentId, orderTreeRow.ChildId, orderTreeRow.RowVersion);
            }
            // Delete the record in the ADO database.
            transaction.DataRows.Add(orderRow);
            orderRow.Delete();
            // Archive the record in the SQL database.
            SqlCommand sqlCommand = new SqlCommand("update Order set Archived = 1 where \"OrderId\"=@orderId");
            sqlCommand.Connection = transaction.SqlConnection;
            sqlCommand.Transaction = transaction.SqlTransaction;
            sqlCommand.Parameters.Add("@orderId", @orderId);
            sqlCommand.ExecuteNonQuery();
        }
    }
}
