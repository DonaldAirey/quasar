//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.288
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

namespace Shadows.WebService.Trading
{
    using Shadows.Quasar.Common;
    using Shadows.Quasar.Server;
	using Shadows.WebService.External;
    using System;
    using System.Collections;
    using System.Data;
    using System.Data.SqlClient;
    
    
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Diagnostics.DebuggerStepThrough()]
    public class WebOrder
    {
        
        /// <summary>Collects the table lock request(s) for an 'Insert' operation</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit</param>
        public static void Insert(Transaction transaction)
        {
            // Call the internal methods to lock the tables required for an insert or update operation.
            Shadows.WebService.Trading.Order.Insert(transaction);
            // These table lock(s) are required for the 'Insert' operation.
            transaction.Locks.AddReaderLock(ServerMarketData.OrderLock);
            transaction.Locks.AddReaderLock(ServerMarketData.ConfigurationLock);
            transaction.Locks.AddReaderLock(ServerMarketData.ObjectLock);
            transaction.Locks.AddReaderLock(ServerMarketData.AccountLock);
            transaction.Locks.AddReaderLock(ServerMarketData.OrderTypeLock);
            transaction.Locks.AddReaderLock(ServerMarketData.SecurityLock);
            transaction.Locks.AddReaderLock(ServerMarketData.TimeInForceLock);
            transaction.Locks.AddReaderLock(ServerMarketData.TransactionTypeLock);
        }
        
        /// <summary>Inserts a Order record using Metadata Parameters.</summary>
        /// <param name="transaction">Commits or rejects a set of commands as a unit</param>
        /// <param name="remoteMethod">Contains the parameters and exceptions for this command.</param>
        public static void Insert(Transaction transaction, RemoteMethod remoteMethod)
        {
            try
            {
                // Accessor for the Order Table.
                ServerMarketData.OrderDataTable orderTable = ServerMarketData.Order;
                // Extract the parameters from the command batch.
                string configurationId = remoteMethod.Parameters.GetRequiredString("configurationId", "DEFAULT");
                string externalAccountId = remoteMethod.Parameters.GetRequiredString("accountId");
                string externalSecurityId = remoteMethod.Parameters.GetRequiredString("securityId");
                string externalSettlementId = remoteMethod.Parameters.GetRequiredString("settlementId");
                string externalTransactionTypeCode = remoteMethod.Parameters.GetRequiredString("transactionTypeCode");
                string externalTimeInForceCode = remoteMethod.Parameters.GetRequiredString("timeInForceCode");
                string externalOrderTypeCode = remoteMethod.Parameters.GetRequiredString("orderTypeCode");
                System.Decimal quantity = remoteMethod.Parameters.GetRequiredDecimal("quantity");
                object price1 = remoteMethod.Parameters.GetOptionalDecimal("price1");
                object price2 = remoteMethod.Parameters.GetOptionalDecimal("price2");
                // Make sure the parameters were parsed correctly before calling the internal method. This will prevent the method
                // from being called with bad data, but provides for error checking on all the parameters.
                if ((remoteMethod.HasExceptions == false))
                {
                    // The row versioning is largely disabled for external operations.  The value is returned to the caller in the
                    // event it's needed for operations within the batch.
                    long rowVersion = long.MinValue;
                    // Resolve External Identifiers
                    int accountId = External.Account.FindRequiredKey(configurationId, "accountId", externalAccountId);
                    int securityId = External.Security.FindRequiredKey(configurationId, "securityId", externalSecurityId);
                    int settlementId = External.Security.FindRequiredKey(configurationId, "settlementId", externalSettlementId);
                    int transactionTypeCode = External.TransactionType.FindRequiredKey(configurationId, "transactionTypeCode", externalTransactionTypeCode);
                    int timeInForceCode = External.TimeInForce.FindRequiredKey(configurationId, "timeInForceCode", externalTimeInForceCode);
                    int orderTypeCode = External.OrderType.FindRequiredKey(configurationId, "orderTypeCode", externalOrderTypeCode);
                    // Call the internal method to complete the operation.
                    Shadows.WebService.Trading.Order.Insert(transaction, null, null, accountId, securityId, settlementId, null, transactionTypeCode, timeInForceCode, orderTypeCode, null, ref rowVersion, null, quantity, price1, price2, null);
                    // Return values.
                    remoteMethod.Parameters.ReturnValue("rowVersion", rowVersion);
                }
            }
            catch (SqlException sqlException)
            {
                // Every exception from the SQL server call is packed into the 'RemoteMethod' structure and returned to the caller.
                for (IEnumerator iEnumerator = sqlException.Errors.GetEnumerator(); iEnumerator.MoveNext(); remoteMethod.Exceptions.Add(((SqlError)(iEnumerator.Current)).Message))
                {
                }
            }
            catch (Exception exception)
            {
                // This will pass the general exception back to the caller.
                remoteMethod.Exceptions.Add(exception);
            }
        }
    }
}
